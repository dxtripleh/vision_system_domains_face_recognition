---
description: 
globs: 
alwaysApply: false
---
# ë‹¤ì¤‘ ë„ë©”ì¸ ê´€ë¦¬ (ADVANCED)

## ğŸ—ï¸ ë„ë©”ì¸ í™•ì¥ ì „ëµ

### ìƒˆë¡œìš´ ë„ë©”ì¸ ì¶”ê°€ ì ˆì°¨
```python
# ë„ë©”ì¸ ì¶”ê°€ ì‹œ ì²´í¬ë¦¬ìŠ¤íŠ¸
DOMAIN_ADDITION_CHECKLIST = {
    'preparation': [
        'domain_requirements_analysis',      # ë„ë©”ì¸ ìš”êµ¬ì‚¬í•­ ë¶„ì„
        'architecture_design',              # ì•„í‚¤í…ì²˜ ì„¤ê³„
        'data_strategy_planning',           # ë°ì´í„° ì „ëµ ê³„íš
        'integration_points_identification' # í†µí•© ì§€ì  ì‹ë³„
    ],
    'implementation': [
        'domain_structure_creation',        # ë„ë©”ì¸ êµ¬ì¡° ìƒì„±
        'core_entities_definition',         # í•µì‹¬ ì—”í‹°í‹° ì •ì˜
        'services_implementation',          # ì„œë¹„ìŠ¤ êµ¬í˜„
        'infrastructure_setup',             # ì¸í”„ë¼ ì„¤ì •
        'interfaces_development'            # ì¸í„°í˜ì´ìŠ¤ ê°œë°œ
    ],
    'integration': [
        'shared_modules_extension',         # ê³µìœ  ëª¨ë“ˆ í™•ì¥
        'communication_channels_setup',     # í†µì‹  ì±„ë„ ì„¤ì •
        'event_system_integration',         # ì´ë²¤íŠ¸ ì‹œìŠ¤í…œ í†µí•©
        'data_pipeline_connection'          # ë°ì´í„° íŒŒì´í”„ë¼ì¸ ì—°ê²°
    ],
    'validation': [
        'unit_tests_creation',              # ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ ìƒì„±
        'integration_tests_development',    # í†µí•© í…ŒìŠ¤íŠ¸ ê°œë°œ
        'performance_testing',              # ì„±ëŠ¥ í…ŒìŠ¤íŠ¸
        'end_to_end_testing'               # ì¢…ë‹¨ê°„ í…ŒìŠ¤íŠ¸
    ]
}

def create_new_domain(domain_name: str, domain_type: str):
    """ìƒˆë¡œìš´ ë„ë©”ì¸ ìƒì„±"""
    
    # 1. ë„ë©”ì¸ ë””ë ‰í† ë¦¬ êµ¬ì¡° ìƒì„±
    domain_path = f"domains/{domain_name}"
    
    structure = {
        'core': ['entities', 'services', 'value_objects'],
        'infrastructure': ['models', 'storage', 'external_apis'],
        'interfaces': ['api', 'cli'],
        'runners': ['training', 'inference', 'demo']
    }
    
    for layer, subdirs in structure.items():
        layer_path = os.path.join(domain_path, layer)
        os.makedirs(layer_path, exist_ok=True)
        
        # __init__.py íŒŒì¼ ìƒì„±
        with open(os.path.join(layer_path, '__init__.py'), 'w') as f:
            f.write(f'"""Domain: {domain_name} - Layer: {layer}"""\n')
        
        for subdir in subdirs:
            subdir_path = os.path.join(layer_path, subdir)
            os.makedirs(subdir_path, exist_ok=True)
            
            with open(os.path.join(subdir_path, '__init__.py'), 'w') as f:
                f.write(f'"""Domain: {domain_name} - {layer}.{subdir}"""\n')
    
    # 2. ë„ë©”ì¸ë³„ ì„¤ì • íŒŒì¼ ìƒì„±
    create_domain_config(domain_name, domain_type)
    
    # 3. README íŒŒì¼ ìƒì„±
    create_domain_readme(domain_name, domain_type)
    
    print(f"âœ“ Domain '{domain_name}' created successfully")
```

### ë‹¤ì¤‘ ë„ë©”ì¸ í™•ì¥ ê³„íš
```python
# í–¥í›„ ë„ë©”ì¸ í™•ì¥ ë¡œë“œë§µ
DOMAIN_EXPANSION_ROADMAP = {
    'factory_defect': {
        'priority': 'high',
        'estimated_timeline': '3-4 months',
        'dependencies': ['vision_core', 'monitoring_system'],
        'requirements': {
            'hardware': ['industrial_cameras', 'lighting_system'],
            'models': ['defect_detection', 'classification'],
            'data': ['factory_samples', 'defect_annotations']
        },
        'integration_points': [
            'shared.vision_core.detection',
            'shared.vision_core.preprocessing',
            'quality_metrics_tracking'
        ]
    },
    'powerline_inspection': {
        'priority': 'medium',
        'estimated_timeline': '4-6 months',
        'dependencies': ['vision_core', 'drone_integration'],
        'requirements': {
            'hardware': ['drone_cameras', 'gps_module', 'thermal_camera'],
            'models': ['powerline_detection', 'defect_classification', 'thermal_analysis'],
            'data': ['aerial_images', 'thermal_data', 'gps_coordinates']
        },
        'integration_points': [
            'shared.vision_core.detection',
            'shared.vision_core.tracking',
            'geolocation_services'
        ]
    },
    'medical_imaging': {
        'priority': 'low',
        'estimated_timeline': '6-8 months',
        'dependencies': ['vision_core', 'security_enhanced', 'privacy_compliance'],
        'requirements': {
            'hardware': ['medical_scanners', 'dicom_compatible'],
            'models': ['anomaly_detection', 'segmentation', 'diagnosis_support'],
            'data': ['medical_images', 'anonymized_datasets', 'expert_annotations']
        },
        'integration_points': [
            'shared.vision_core.preprocessing',
            'shared.security.gdpr_compliance',
            'medical_data_protection'
        ]
    }
}
```

## ğŸ”— ë„ë©”ì¸ ê°„ í†µì‹  ì‹œìŠ¤í…œ

### ì´ë²¤íŠ¸ ê¸°ë°˜ í†µì‹ 
```python
# shared/communication/event_bus.py
from abc import ABC, abstractmethod
from typing import Dict, List, Callable, Any
import asyncio
import json
from dataclasses import dataclass
from datetime import datetime

@dataclass
class DomainEvent:
    """ë„ë©”ì¸ ì´ë²¤íŠ¸ ê¸°ë³¸ í´ë˜ìŠ¤"""
    event_id: str
    domain: str
    event_type: str
    data: Dict[str, Any]
    timestamp: datetime
    version: str = "1.0"

class EventHandler(ABC):
    """ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬ ì¶”ìƒ í´ë˜ìŠ¤"""
    
    @abstractmethod
    async def handle(self, event: DomainEvent) -> None:
        pass

class EventBus:
    """ë„ë©”ì¸ ê°„ ì´ë²¤íŠ¸ ë²„ìŠ¤"""
    
    def __init__(self):
        self.handlers: Dict[str, List[EventHandler]] = {}
        self.event_store: List[DomainEvent] = []
        
    def subscribe(self, event_type: str, handler: EventHandler):
        """ì´ë²¤íŠ¸ êµ¬ë…"""
        if event_type not in self.handlers:
            self.handlers[event_type] = []
        self.handlers[event_type].append(handler)
    
    async def publish(self, event: DomainEvent):
        """ì´ë²¤íŠ¸ ë°œí–‰"""
        # ì´ë²¤íŠ¸ ì €ì¥
        self.event_store.append(event)
        
        # í•¸ë“¤ëŸ¬ë“¤ì—ê²Œ ì´ë²¤íŠ¸ ì „ë‹¬
        if event.event_type in self.handlers:
            tasks = [
                handler.handle(event) 
                for handler in self.handlers[event.event_type]
            ]
            await asyncio.gather(*tasks, return_exceptions=True)
    
    def get_events_by_domain(self, domain: str) -> List[DomainEvent]:
        """ë„ë©”ì¸ë³„ ì´ë²¤íŠ¸ ì¡°íšŒ"""
        return [event for event in self.event_store if event.domain == domain]

# ì´ë²¤íŠ¸ ë²„ìŠ¤ ì‹±ê¸€í†¤ ì¸ìŠ¤í„´ìŠ¤
event_bus = EventBus()
```

### ë„ë©”ì¸ë³„ ì´ë²¤íŠ¸ ì •ì˜
```python
# ì–¼êµ´ì¸ì‹ ë„ë©”ì¸ ì´ë²¤íŠ¸
class FaceDetectedEvent(DomainEvent):
    """ì–¼êµ´ ê°ì§€ ì´ë²¤íŠ¸"""
    
    def __init__(self, face_data: Dict):
        super().__init__(
            event_id=f"face_detected_{int(time.time())}",
            domain="face_recognition",
            event_type="face_detected",
            data=face_data,
            timestamp=datetime.now()
        )

class PersonRecognizedEvent(DomainEvent):
    """ì¸ë¬¼ ì¸ì‹ ì´ë²¤íŠ¸"""
    
    def __init__(self, person_data: Dict):
        super().__init__(
            event_id=f"person_recognized_{int(time.time())}",
            domain="face_recognition",
            event_type="person_recognized",
            data=person_data,
            timestamp=datetime.now()
        )

# ê³µì¥ ë¶ˆëŸ‰ ê²€ì¶œ ë„ë©”ì¸ ì´ë²¤íŠ¸ (í–¥í›„)
class DefectDetectedEvent(DomainEvent):
    """ë¶ˆëŸ‰ ê°ì§€ ì´ë²¤íŠ¸"""
    
    def __init__(self, defect_data: Dict):
        super().__init__(
            event_id=f"defect_detected_{int(time.time())}",
            domain="factory_defect",
            event_type="defect_detected",
            data=defect_data,
            timestamp=datetime.now()
        )

# ì „ì„  ê²€ì‚¬ ë„ë©”ì¸ ì´ë²¤íŠ¸ (í–¥í›„)
class PowerlineAnomalyEvent(DomainEvent):
    """ì „ì„  ì´ìƒ ê°ì§€ ì´ë²¤íŠ¸"""
    
    def __init__(self, anomaly_data: Dict):
        super().__init__(
            event_id=f"powerline_anomaly_{int(time.time())}",
            domain="powerline_inspection",
            event_type="powerline_anomaly",
            data=anomaly_data,
            timestamp=datetime.now()
        )
```

### ë„ë©”ì¸ ê°„ ë°ì´í„° ê³µìœ 
```python
# shared/data/domain_data_manager.py
class DomainDataManager:
    """ë„ë©”ì¸ ê°„ ë°ì´í„° ê³µìœ  ê´€ë¦¬"""
    
    def __init__(self):
        self.shared_cache = {}
        self.data_contracts = {}
    
    def register_data_contract(self, contract_name: str, schema: Dict):
        """ë°ì´í„° ê³„ì•½ ë“±ë¡"""
        self.data_contracts[contract_name] = schema
    
    def share_data(self, contract_name: str, data: Dict, source_domain: str):
        """ë°ì´í„° ê³µìœ """
        if contract_name not in self.data_contracts:
            raise ValueError(f"Unknown data contract: {contract_name}")
        
        # ìŠ¤í‚¤ë§ˆ ê²€ì¦
        if not self._validate_schema(data, self.data_contracts[contract_name]):
            raise ValueError("Data does not match contract schema")
        
        # ê³µìœ  ìºì‹œì— ì €ì¥
        self.shared_cache[contract_name] = {
            'data': data,
            'source_domain': source_domain,
            'timestamp': datetime.now()
        }
    
    def get_shared_data(self, contract_name: str) -> Dict:
        """ê³µìœ  ë°ì´í„° ì¡°íšŒ"""
        if contract_name not in self.shared_cache:
            return None
        return self.shared_cache[contract_name]
    
    def _validate_schema(self, data: Dict, schema: Dict) -> bool:
        """ìŠ¤í‚¤ë§ˆ ê²€ì¦"""
        # ê°„ë‹¨í•œ ìŠ¤í‚¤ë§ˆ ê²€ì¦ êµ¬í˜„
        for field, field_type in schema.items():
            if field not in data:
                return False
            if not isinstance(data[field], field_type):
                return False
        return True

# ë°ì´í„° ê³„ì•½ ì •ì˜
DATA_CONTRACTS = {
    'detected_object': {
        'bbox': list,           # [x, y, width, height]
        'confidence': float,    # 0.0 ~ 1.0
        'class_name': str,      # ê°ì²´ í´ë˜ìŠ¤ëª…
        'timestamp': str        # ISO 8601 í˜•ì‹
    },
    'processing_result': {
        'success': bool,        # ì²˜ë¦¬ ì„±ê³µ ì—¬ë¶€
        'processing_time': float, # ì²˜ë¦¬ ì‹œê°„ (ì´ˆ)
        'result_data': dict,    # ê²°ê³¼ ë°ì´í„°
        'error_message': str    # ì—ëŸ¬ ë©”ì‹œì§€ (ìˆëŠ” ê²½ìš°)
    },
    'quality_metrics': {
        'accuracy': float,      # ì •í™•ë„
        'precision': float,     # ì •ë°€ë„
        'recall': float,        # ì¬í˜„ìœ¨
        'f1_score': float      # F1 ìŠ¤ì½”ì–´
    }
}
```

## ğŸ”„ ê³µìœ  ëª¨ë“ˆ í™•ì¥ ê´€ë¦¬

### Shared ëª¨ë“ˆ í™•ì¥ ì „ëµ
```python
# shared ëª¨ë“ˆ í™•ì¥ ê³„íš
SHARED_MODULE_EXPANSION = {
    'vision_core': {
        'current_modules': [
            'detection',           # ê°ì²´/ì–¼êµ´ ê²€ì¶œ
            'recognition',         # ì¸ì‹
            'preprocessing',       # ì „ì²˜ë¦¬
            'postprocessing'       # í›„ì²˜ë¦¬
        ],
        'planned_modules': [
            'tracking',           # ê°ì²´ ì¶”ì  (factory_defectìš©)
            'pose_estimation',    # ìì„¸ ì¶”ì • (powerline_inspectionìš©)
            'thermal_analysis',   # ì—´í™”ìƒ ë¶„ì„ (powerline_inspectionìš©)
            'medical_processing'  # ì˜ë£Œ ì˜ìƒ ì²˜ë¦¬ (medical_imagingìš©)
        ]
    },
    'communication': {
        'current_modules': [
            'event_bus',          # ì´ë²¤íŠ¸ ë²„ìŠ¤
            'data_manager'        # ë°ì´í„° ê´€ë¦¬
        ],
        'planned_modules': [
            'message_queue',      # ë©”ì‹œì§€ í (ëŒ€ìš©ëŸ‰ ì²˜ë¦¬ìš©)
            'real_time_sync',     # ì‹¤ì‹œê°„ ë™ê¸°í™” (ë‹¤ì¤‘ ì¹´ë©”ë¼ìš©)
            'distributed_cache'   # ë¶„ì‚° ìºì‹œ (í™•ì¥ì„±ìš©)
        ]
    },
    'quality': {
        'current_modules': [],
        'planned_modules': [
            'metrics_aggregator', # ë©”íŠ¸ë¦­ ìˆ˜ì§‘ê¸°
            'quality_dashboard',  # í’ˆì§ˆ ëŒ€ì‹œë³´ë“œ
            'alert_system',       # ì•Œë¦¼ ì‹œìŠ¤í…œ
            'reporting'           # ë¦¬í¬íŒ… ì‹œìŠ¤í…œ
        ]
    }
}

def extend_shared_module(module_name: str, new_component: str):
    """ê³µìœ  ëª¨ë“ˆ í™•ì¥"""
    
    # 1. ìƒˆë¡œìš´ ì»´í¬ë„ŒíŠ¸ ë””ë ‰í† ë¦¬ ìƒì„±
    component_path = f"shared/{module_name}/{new_component}"
    os.makedirs(component_path, exist_ok=True)
    
    # 2. __init__.py íŒŒì¼ ìƒì„±
    init_file = os.path.join(component_path, '__init__.py')
    with open(init_file, 'w') as f:
        f.write(f'"""Shared module: {module_name}.{new_component}"""\n')
    
    # 3. ê¸°ë³¸ êµ¬í˜„ íŒŒì¼ ìƒì„±
    impl_file = os.path.join(component_path, f'{new_component}.py')
    with open(impl_file, 'w') as f:
        f.write(generate_component_template(module_name, new_component))
    
    # 4. í…ŒìŠ¤íŠ¸ íŒŒì¼ ìƒì„±
    test_dir = f"tests/shared/{module_name}"
    os.makedirs(test_dir, exist_ok=True)
    
    test_file = os.path.join(test_dir, f'test_{new_component}.py')
    with open(test_file, 'w') as f:
        f.write(generate_test_template(module_name, new_component))
    
    print(f"âœ“ Shared module component '{module_name}.{new_component}' created")

def generate_component_template(module_name: str, component_name: str) -> str:
    """ì»´í¬ë„ŒíŠ¸ í…œí”Œë¦¿ ìƒì„±"""
    template = f'''#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
{module_name}.{component_name} ëª¨ë“ˆ

ì´ ëª¨ë“ˆì€ {component_name} ê¸°ëŠ¥ì„ ì œê³µí•©ë‹ˆë‹¤.
"""

import logging
from typing import Dict, List, Optional, Any

logger = logging.getLogger(__name__)

class {component_name.title().replace('_', '')}:
    """{ component_name.replace('_', ' ').title()} í´ë˜ìŠ¤"""
    
    def __init__(self):
        self.initialized = False
        self._setup()
    
    def _setup(self):
        """ì´ˆê¸° ì„¤ì •"""
        logger.info(f"Initializing {{self.__class__.__name__}}")
        self.initialized = True
    
    def process(self, data: Any) -> Any:
        """ë©”ì¸ ì²˜ë¦¬ ë©”ì„œë“œ"""
        if not self.initialized:
            raise RuntimeError("Component not initialized")
        
        # êµ¬í˜„ í•„ìš”
        raise NotImplementedError("Subclass must implement process method")

# íŒ©í† ë¦¬ í•¨ìˆ˜
def create_{component_name}() -> {component_name.title().replace('_', '')}:
    """{ component_name.replace('_', ' ').title()} ì¸ìŠ¤í„´ìŠ¤ ìƒì„±"""
    return {component_name.title().replace('_', '')}()
'''
    return template
```

## ğŸ“Š ë‹¤ì¤‘ ë„ë©”ì¸ ë©”íŠ¸ë¦­ ê´€ë¦¬

### í†µí•© ë©”íŠ¸ë¦­ ì‹œìŠ¤í…œ
```python
# shared/quality/metrics_aggregator.py
class DomainMetricsAggregator:
    """ë„ë©”ì¸ë³„ ë©”íŠ¸ë¦­ í†µí•© ê´€ë¦¬"""
    
    def __init__(self):
        self.domain_metrics = {}
        self.metric_definitions = {}
    
    def register_domain_metrics(self, domain: str, metrics_config: Dict):
        """ë„ë©”ì¸ë³„ ë©”íŠ¸ë¦­ ë“±ë¡"""
        self.domain_metrics[domain] = {
            'config': metrics_config,
            'current_values': {},
            'history': []
        }
    
    def update_metric(self, domain: str, metric_name: str, value: float):
        """ë©”íŠ¸ë¦­ ê°’ ì—…ë°ì´íŠ¸"""
        if domain not in self.domain_metrics:
            raise ValueError(f"Domain {domain} not registered")
        
        self.domain_metrics[domain]['current_values'][metric_name] = value
        self.domain_metrics[domain]['history'].append({
            'metric': metric_name,
            'value': value,
            'timestamp': datetime.now()
        })
    
    def get_cross_domain_summary(self) -> Dict:
        """ë„ë©”ì¸ ê°„ ë©”íŠ¸ë¦­ ìš”ì•½"""
        summary = {
            'total_domains': len(self.domain_metrics),
            'active_domains': 0,
            'overall_health': 'healthy',
            'domain_status': {}
        }
        
        for domain, metrics in self.domain_metrics.items():
            domain_health = self._calculate_domain_health(domain, metrics)
            summary['domain_status'][domain] = domain_health
            
            if domain_health['status'] == 'active':
                summary['active_domains'] += 1
        
        # ì „ì²´ ì‹œìŠ¤í…œ ê±´ê°•ë„ ê³„ì‚°
        if summary['active_domains'] == 0:
            summary['overall_health'] = 'inactive'
        elif any(status['health'] == 'critical' for status in summary['domain_status'].values()):
            summary['overall_health'] = 'critical'
        elif any(status['health'] == 'warning' for status in summary['domain_status'].values()):
            summary['overall_health'] = 'warning'
        
        return summary
    
    def _calculate_domain_health(self, domain: str, metrics: Dict) -> Dict:
        """ë„ë©”ì¸ ê±´ê°•ë„ ê³„ì‚°"""
        current_values = metrics['current_values']
        config = metrics['config']
        
        health_score = 1.0
        status = 'active'
        issues = []
        
        for metric_name, thresholds in config.get('thresholds', {}).items():
            if metric_name in current_values:
                value = current_values[metric_name]
                
                if 'min' in thresholds and value < thresholds['min']:
                    health_score *= 0.7
                    issues.append(f"{metric_name} below minimum: {value} < {thresholds['min']}")
                
                if 'max' in thresholds and value > thresholds['max']:
                    health_score *= 0.7
                    issues.append(f"{metric_name} above maximum: {value} > {thresholds['max']}")
        
        # ê±´ê°•ë„ ë¶„ë¥˜
        if health_score >= 0.8:
            health = 'healthy'
        elif health_score >= 0.6:
            health = 'warning'
        else:
            health = 'critical'
        
        return {
            'status': status,
            'health': health,
            'score': health_score,
            'issues': issues,
            'metrics_count': len(current_values)
        }

# ë„ë©”ì¸ë³„ ë©”íŠ¸ë¦­ ì„¤ì • ì˜ˆì‹œ
DOMAIN_METRICS_CONFIG = {
    'face_recognition': {
        'thresholds': {
            'fps': {'min': 15.0, 'max': 60.0},
            'accuracy': {'min': 0.85, 'max': 1.0},
            'processing_time_ms': {'min': 0.0, 'max': 100.0}
        },
        'alerts': {
            'low_fps': {'condition': 'fps < 15', 'severity': 'warning'},
            'high_latency': {'condition': 'processing_time_ms > 100', 'severity': 'critical'}
        }
    },
    'factory_defect': {  # í–¥í›„
        'thresholds': {
            'defect_rate': {'min': 0.0, 'max': 0.05},
            'false_positive_rate': {'min': 0.0, 'max': 0.02},
            'throughput_per_hour': {'min': 100.0, 'max': 1000.0}
        },
        'alerts': {
            'high_defect_rate': {'condition': 'defect_rate > 0.05', 'severity': 'critical'},
            'low_throughput': {'condition': 'throughput_per_hour < 100', 'severity': 'warning'}
        }
    }
}
```

## ğŸ”§ ë„ë©”ì¸ ë…ë¦½ì„± ë³´ì¥

### ì˜ì¡´ì„± ê²€ì¦ ì‹œìŠ¤í…œ
```python
# scripts/validation/check_domain_independence.py
def validate_domain_independence():
    """ë„ë©”ì¸ ë…ë¦½ì„± ê²€ì¦"""
    
    violations = []
    
    # 1. ì§ì ‘ import ê²€ì¦
    direct_import_violations = check_direct_domain_imports()
    violations.extend(direct_import_violations)
    
    # 2. ìˆœí™˜ ì˜ì¡´ì„± ê²€ì¦
    circular_dependencies = check_circular_dependencies()
    violations.extend(circular_dependencies)
    
    # 3. ê³µìœ  ëª¨ë“ˆ ì‚¬ìš© ê²€ì¦
    shared_module_violations = check_shared_module_usage()
    violations.extend(shared_module_violations)
    
    # 4. ë¦¬í¬íŠ¸ ìƒì„±
    generate_independence_report(violations)
    
    return len(violations) == 0

def check_direct_domain_imports():
    """ë„ë©”ì¸ ê°„ ì§ì ‘ import ê²€ì‚¬"""
    violations = []
    
    for domain_dir in os.listdir('domains/'):
        if not os.path.isdir(f'domains/{domain_dir}'):
            continue
        
        for py_file in Path(f'domains/{domain_dir}').rglob('*.py'):
            with open(py_file, 'r', encoding='utf-8') as f:
                content = f.read()
            
            # domains.other_domain import íŒ¨í„´ ê²€ì‚¬
            import_pattern = r'from\s+domains\.([^.]+)'
            matches = re.findall(import_pattern, content)
            
            for imported_domain in matches:
                if imported_domain != domain_dir:
                    violations.append({
                        'type': 'direct_domain_import',
                        'file': str(py_file),
                        'source_domain': domain_dir,
                        'target_domain': imported_domain,
                        'severity': 'critical'
                    })
    
    return violations

def check_circular_dependencies():
    """ìˆœí™˜ ì˜ì¡´ì„± ê²€ì‚¬"""
    # ê°„ë‹¨í•œ ìˆœí™˜ ì˜ì¡´ì„± ê²€ì‚¬ êµ¬í˜„
    # ì‹¤ì œë¡œëŠ” ë” ì •êµí•œ ê·¸ë˜í”„ ë¶„ì„ì´ í•„ìš”
    return []

def generate_independence_report(violations):
    """ë…ë¦½ì„± ê²€ì¦ ë¦¬í¬íŠ¸ ìƒì„±"""
    report = {
        'timestamp': datetime.now().isoformat(),
        'total_violations': len(violations),
        'violations_by_type': {},
        'violations': violations
    }
    
    # ìœ í˜•ë³„ ìœ„ë°˜ ìˆ˜ ì§‘ê³„
    for violation in violations:
        vtype = violation['type']
        if vtype not in report['violations_by_type']:
            report['violations_by_type'][vtype] = 0
        report['violations_by_type'][vtype] += 1
    
    # ë¦¬í¬íŠ¸ ì €ì¥
    with open('data/runtime/logs/domain_independence_report.json', 'w') as f:
        json.dump(report, f, indent=2)
    
    # ì½˜ì†” ì¶œë ¥
    if violations:
        print(f"âŒ Found {len(violations)} domain independence violations")
        for violation in violations:
            print(f"  - {violation['type']}: {violation['file']}")
    else:
        print("âœ“ Domain independence validation passed")
```


---

**ì ìš© ì‹œì **: factory_defect ë˜ëŠ” powerline_inspection ë„ë©”ì¸ ì¶”ê°€ ì‹œ
**ì˜ì¡´ì„±**: `pip install asyncio dataclasses`
**ì„¤ì •**: ì´ë²¤íŠ¸ ë²„ìŠ¤, ë°ì´í„° ê³„ì•½, ë©”íŠ¸ë¦­ ì •ì˜ í•„ìš”


