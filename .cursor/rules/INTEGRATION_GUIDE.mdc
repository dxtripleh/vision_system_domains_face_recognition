---
description: 
globs: 
alwaysApply: false
---
# ğŸ”„ ê·œì¹™ í†µí•© ê°€ì´ë“œ (CROSS_PLATFORM_COMPATIBILITY ìš°ì„ )

## ğŸ“‹ ê·œì¹™ ìš°ì„ ìˆœìœ„

### 1ìˆœìœ„: CROSS_PLATFORM_COMPATIBILITY.mdc (ì ˆëŒ€ ìš°ì„ )
- ëª¨ë“  ê°œë°œì—ì„œ ë°˜ë“œì‹œ ì¤€ìˆ˜
- ë‹¤ë¥¸ ê·œì¹™ê³¼ ì¶©ëŒ ì‹œ ì´ ê·œì¹™ì´ ìš°ì„ 
- í¬ë¡œìŠ¤ í”Œë«í¼ í˜¸í™˜ì„± ë³´ì¥

### 2ìˆœìœ„: ê¸°ë³¸ ê·œì¹™ë“¤
- python-standards.mdc
- project-structure.mdc
- data-management.mdc
- vision-system-core.mdc

### 3ìˆœìœ„: ê³ ê¸‰ ê·œì¹™ë“¤
- multi-domain.mdc
- security-enhanced.mdc
- monitoring-system.mdc
- automation-tools.mdc

## ğŸ”§ ì£¼ìš” ëª¨ìˆœì  í•´ê²° ë°©ì•ˆ

### 1. ë„ë©”ì¸ êµ¬ì¡° ëª¨ìˆœ í•´ê²°

**ë¬¸ì œ**: CROSS_PLATFORM_COMPATIBILITYëŠ” ë‹¨ìˆœí•œ êµ¬ì¡°ë¥¼ ìš”êµ¬í•˜ì§€ë§Œ, ë‹¤ë¥¸ ê·œì¹™ë“¤ì€ ë³µì¡í•œ DDD íŒ¨í„´ì„ ìš”êµ¬

**í•´ê²°ì±…**:
```python
# âœ… í‘œì¤€ êµ¬ì¡° (CROSS_PLATFORM_COMPATIBILITY ìš°ì„ ) - í˜„ì¬ êµ¬ì¡° ë°˜ì˜
domains/{domain_category}/{feature_name}/
â”œâ”€â”€ model.py        # ONNX ëª¨ë¸ í´ë˜ìŠ¤
â”œâ”€â”€ run.py          # ì‹¤ì‹œê°„ ì¶”ë¡  ì‹¤í–‰
â””â”€â”€ test_model.py   # ë‹¨ìœ„ í…ŒìŠ¤íŠ¸

# âœ… ê³ ê¸‰ êµ¬ì¡° (ì„ íƒì , ê³ ê¸‰ ê¸°ëŠ¥ìš©)
domains/{domain_category}/advanced/
â”œâ”€â”€ core/           # DDD íŒ¨í„´
â”œâ”€â”€ infrastructure/
â”œâ”€â”€ interfaces/
â””â”€â”€ runners/
```

### 2. ì‹¤í–‰ íŒŒì¼ ë„¤ì´ë° ëª¨ìˆœ í•´ê²°

**ë¬¸ì œ**: CROSS_PLATFORM_COMPATIBILITYëŠ” `run.py`ë¥¼ ìš”êµ¬í•˜ì§€ë§Œ, python-standardsëŠ” `run_*.py` íŒ¨í„´ì„ ìš”êµ¬

**í•´ê²°ì±…**:
```python
# âœ… í•„ìˆ˜ íŒŒì¼ (CROSS_PLATFORM_COMPATIBILITY ê·œì¹™)
run.py              # ê¸°ë³¸ ì‹¤í–‰ íŒŒì¼

# âœ… ì„ íƒì  íŒŒì¼ (ì¶”ê°€ ê¸°ëŠ¥ìš©)
run_gui.py          # GUI ë²„ì „
run_headless.py     # Headless ë²„ì „
run_demo.py         # ë°ëª¨ ë²„ì „
```

### 3. ëª¨ë¸ í¬ë§· ëª¨ìˆœ í•´ê²°

**ë¬¸ì œ**: CROSS_PLATFORM_COMPATIBILITYëŠ” .onnxë§Œ í—ˆìš©í•˜ì§€ë§Œ, ë‹¤ë¥¸ ê·œì¹™ë“¤ì€ .ptë„ ì‚¬ìš©

**í•´ê²°ì±…**:
```python
# âœ… í•™ìŠµ ë‹¨ê³„
model.pt            # PyTorch ëª¨ë¸ (í•™ìŠµìš©)

# âœ… ì¶”ë¡  ë‹¨ê³„ (CROSS_PLATFORM_COMPATIBILITY í•„ìˆ˜)
model.onnx          # ONNX ëª¨ë¸ (ì¶”ë¡ ìš©)

# âœ… ëª¨ë¸ ê°€ì¤‘ì¹˜ ë„¤ì´ë°
{task}_{architecture}_{dataset}_{date}.onnx
```

## ğŸ“ ì‹¤ì œ í”„ë¡œì íŠ¸ êµ¬ì¡° ì˜ˆì‹œ (í˜„ì¬ êµ¬ì¡° ë°˜ì˜)

```
vision_system/
â”œâ”€â”€ domains/
â”‚   â”œâ”€â”€ humanoid/              # ì¸ê°„í˜• ë„ë©”ì¸
â”‚   â”‚   â””â”€â”€ face_recognition/  # ì–¼êµ´ì¸ì‹ ê¸°ëŠ¥
â”‚   â”‚       â”œâ”€â”€ model.py
â”‚   â”‚       â”œâ”€â”€ run.py
â”‚   â”‚       â””â”€â”€ test_model.py
â”‚   â”œâ”€â”€ factory/               # ê³µì¥ ë„ë©”ì¸
â”‚   â”‚   â””â”€â”€ defect_detection/  # ë¶ˆëŸ‰ ê²€ì¶œ ê¸°ëŠ¥
â”‚   â”‚       â”œâ”€â”€ model.py
â”‚   â”‚       â”œâ”€â”€ run.py
â”‚   â”‚       â””â”€â”€ test_model.py
â”‚   â””â”€â”€ powerline_inspection/  # í™œì„  ê²€ì‚¬ ë„ë©”ì¸ (í–¥í›„)
â”‚       â””â”€â”€ inspection/
â”‚           â”œâ”€â”€ model.py
â”‚           â”œâ”€â”€ run.py
â”‚           â””â”€â”€ test_model.py
â”œâ”€â”€ shared/
â”‚   â””â”€â”€ vision_core/           # ë¹„ì „ ì•Œê³ ë¦¬ì¦˜ ê³µí†µ ê¸°ëŠ¥ (í–¥í›„ ìƒì„± í•„ìš”)
â”œâ”€â”€ common/
â”œâ”€â”€ config/                    # ì„¤ì • íŒŒì¼ (í˜„ì¬ ëˆ„ë½, ìƒì„± í•„ìš”)
â”œâ”€â”€ models/                    # ëª¨ë¸ ì €ì¥ì†Œ (í˜„ì¬ ëˆ„ë½, ìƒì„± í•„ìš”)
â”‚   â””â”€â”€ weights/               # .onnx íŒŒì¼ë§Œ ì €ì¥
â”œâ”€â”€ datasets/                  # í•™ìŠµ ë°ì´í„° (í˜„ì¬ ëˆ„ë½, ìƒì„± í•„ìš”)
â”œâ”€â”€ data/
â”‚   â”œâ”€â”€ temp/                  # ì„ì‹œ íŒŒì¼ (ìë™ ì •ë¦¬)
â”‚   â”œâ”€â”€ logs/                  # ë¡œê·¸ íŒŒì¼
â”‚   â”œâ”€â”€ output/                # ê²°ê³¼ë¬¼ ì €ì¥
â”‚   â””â”€â”€ domains/               # ë„ë©”ì¸ë³„ ë°ì´í„° (í˜„ì¬ ëˆ„ë½, ìƒì„± í•„ìš”)
â”‚       â”œâ”€â”€ humanoid/          # ì¸ê°„í˜• ë„ë©”ì¸ ë°ì´í„°
â”‚       â””â”€â”€ factory/           # ê³µì¥ ë„ë©”ì¸ ë°ì´í„°
â”œâ”€â”€ scripts/                   # ê°œë°œ ë„êµ¬ ìŠ¤í¬ë¦½íŠ¸ (í˜„ì¬ ëˆ„ë½, ìƒì„± í•„ìš”)
â””â”€â”€ tests/
```

## ğŸ”„ ê·œì¹™ ì ìš© ì²´í¬ë¦¬ìŠ¤íŠ¸

### ëª¨ë“  ìƒˆ ê¸°ëŠ¥ ê°œë°œ ì‹œ í™•ì¸ì‚¬í•­

#### 1. CROSS_PLATFORM_COMPATIBILITY ì¤€ìˆ˜
- [ ] `from pathlib import Path` import í¬í•¨
- [ ] í•˜ë“œì½”ë”©ëœ ê²½ë¡œ ì—†ìŒ
- [ ] `os.path.join()` ë˜ëŠ” `Path` ì‚¬ìš©
- [ ] Python 3.10+ í˜¸í™˜ì„± ê³ ë ¤
- [ ] í•˜ë“œì›¨ì–´ í™˜ê²½ ìë™ ê°ì§€
- [ ] í”Œë«í¼ë³„ ì¹´ë©”ë¼ ë°±ì—”ë“œ ì‚¬ìš©
- [ ] ONNX ëª¨ë¸ ì‚¬ìš© (ì¶”ë¡  ì‹œ)
- [ ] ì‹œë®¬ë ˆì´ì…˜ ëª¨ë“œ ê¸ˆì§€

#### 2. ë„ë©”ì¸ êµ¬ì¡° ì¤€ìˆ˜ (í˜„ì¬ êµ¬ì¡° ë°˜ì˜)
- [ ] `domains/{domain_category}/{feature_name}/` êµ¬ì¡° ì‚¬ìš©
- [ ] `model.py`, `run.py`, `test_model.py` í•„ìˆ˜ íŒŒì¼ í¬í•¨
- [ ] `__init__.py` íŒŒì¼ í¬í•¨
- [ ] README.md íŒŒì¼ í¬í•¨

#### 3. Python í‘œì¤€ ì¤€ìˆ˜
- [ ] íŒŒì¼ í—¤ë” í¬í•¨
- [ ] Import ìˆœì„œ ì¤€ìˆ˜
- [ ] Type hints ì‚¬ìš©
- [ ] Docstring ì‘ì„±
- [ ] ë¡œê¹… ì‚¬ìš© (print() ê¸ˆì§€)
- [ ] ì˜ˆì™¸ ì²˜ë¦¬ í¬í•¨

#### 4. ë°ì´í„° ê´€ë¦¬ ì¤€ìˆ˜
- [ ] ì„ì‹œ íŒŒì¼ì„ `data/temp/`ì— ì €ì¥
- [ ] ë¡œê·¸ íŒŒì¼ì„ `data/logs/`ì— ì €ì¥
- [ ] ê²°ê³¼ë¬¼ì„ `data/output/`ì— ì €ì¥
- [ ] ëª¨ë¸ íŒŒì¼ì„ `models/weights/`ì— ì €ì¥

## ğŸš¨ ê¸ˆì§€ ì‚¬í•­ í†µí•©

### ì ˆëŒ€ ê¸ˆì§€ (ëª¨ë“  ê·œì¹™ì—ì„œ)
1. **í•˜ë“œì½”ë”©ëœ ê²½ë¡œ ì‚¬ìš©**
2. **ì‹œë®¬ë ˆì´ì…˜ ëª¨ë“œ ì‚¬ìš©**
3. **.pt íŒŒì¼ë¡œ ì¶”ë¡  (ONNX í•„ìˆ˜)**
4. **print() ë¬¸ ì‚¬ìš© (ë¡œê¹… ì‚¬ìš©)**
5. **ì˜ˆì™¸ ì²˜ë¦¬ ì—†ëŠ” ë¦¬ì†ŒìŠ¤ ì‚¬ìš©**
6. **ë„ë©”ì¸ ê°„ ì§ì ‘ import**
7. **ë£¨íŠ¸ ë””ë ‰í† ë¦¬ì— ì„ì‹œ íŒŒì¼ ìƒì„±**

### CROSS_PLATFORM_COMPATIBILITY íŠ¹í™” ê¸ˆì§€
1. **ë°±ìŠ¬ë˜ì‹œ ì‚¬ìš© (`\`)**
2. **Windows/Linux ì „ìš© ê²½ë¡œ**
3. **í•˜ë“œì›¨ì–´ ì—°ê²° ì—†ì´ ì‹¤í–‰**
4. **ê°€ì§œ í”„ë ˆì„/ì¹´ë©”ë¼ ì‚¬ìš©**

## ğŸ“ ì½”ë“œ í…œí”Œë¦¿ (í˜„ì¬ êµ¬ì¡° ë°˜ì˜)

### í‘œì¤€ model.py í…œí”Œë¦¿
```python
#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
{domain_category} {feature_name} ONNX ëª¨ë¸ í´ë˜ìŠ¤.

ì´ ëª¨ë“ˆì€ {feature_name} ê¸°ëŠ¥ì˜ ONNX ëª¨ë¸ ë¡œë”© ë° ì¶”ë¡  ì²˜ë¦¬ë¥¼ ì œê³µí•©ë‹ˆë‹¤.
"""

import os
import sys
import logging
from pathlib import Path  # CROSS_PLATFORM_COMPATIBILITY í•„ìˆ˜
from typing import Dict, List, Optional, Tuple, Union
import numpy as np
import onnxruntime as ort

# í”„ë¡œì íŠ¸ ë£¨íŠ¸ ê²½ë¡œ ì¶”ê°€
project_root = Path(__file__).parent.parent.parent.parent
sys.path.append(str(project_root))

from common.logging import get_logger

logger = get_logger(__name__)

class {FeatureName}Model:
    """{feature_name} ONNX ëª¨ë¸ í´ë˜ìŠ¤"""
    
    def __init__(self, model_path: Optional[str] = None, config: Optional[Dict] = None):
        """ëª¨ë¸ ì´ˆê¸°í™”"""
        self.config = config or {}
        
        # ëª¨ë¸ ê²½ë¡œ ì„¤ì • (CROSS_PLATFORM_COMPATIBILITY)
        if model_path is None:
            model_path = project_root / "models" / "weights" / f"{feature_name}.onnx"
        
        self.model_path = Path(model_path)
        
        if not self.model_path.exists():
            raise FileNotFoundError(f"Model file not found: {self.model_path}")
        
        # ONNX ëŸ°íƒ€ì„ ì„¸ì…˜ ìƒì„±
        self._create_session()
        
        logger.info(f"{FeatureName}Model initialized")
    
    def _create_session(self):
        """ONNX ëŸ°íƒ€ì„ ì„¸ì…˜ ìƒì„±"""
        try:
            # í•˜ë“œì›¨ì–´ í™˜ê²½ì— ë”°ë¥¸ ìµœì í™” í”„ë¡œë°”ì´ë” ì„ íƒ
            providers = ['CUDAExecutionProvider', 'CPUExecutionProvider']
            self.session = ort.InferenceSession(str(self.model_path), providers=providers)
            logger.info(f"ONNX session created with providers: {self.session.get_providers()}")
        except Exception as e:
            logger.error(f"Failed to create ONNX session: {e}")
            raise
    
    def predict(self, image: np.ndarray) -> List[Dict]:
        """ì´ë¯¸ì§€ ì¶”ë¡ """
        try:
            # ì „ì²˜ë¦¬
            input_data = self._preprocess(image)
            
            # ì¶”ë¡ 
            outputs = self.session.run(None, {'input': input_data})
            
            # í›„ì²˜ë¦¬
            results = self._postprocess(outputs)
            
            return results
            
        except Exception as e:
            logger.error(f"Prediction failed: {e}")
            raise
    
    def _preprocess(self, image: np.ndarray) -> np.ndarray:
        """ì´ë¯¸ì§€ ì „ì²˜ë¦¬"""
        # TODO: êµ¬í˜„ í•„ìš”
        return image
    
    def _postprocess(self, outputs: List[np.ndarray]) -> List[Dict]:
        """ì¶”ë¡  ê²°ê³¼ í›„ì²˜ë¦¬"""
        # TODO: êµ¬í˜„ í•„ìš”
        return []
```

### í‘œì¤€ run.py í…œí”Œë¦¿
```python
#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
{domain_category} {feature_name} ì‹¤ì‹œê°„ ì¶”ë¡  ì‹¤í–‰ ìŠ¤í¬ë¦½íŠ¸.

ì´ ìŠ¤í¬ë¦½íŠ¸ëŠ” USB ì¹´ë©”ë¼ ë˜ëŠ” ì´ë¯¸ì§€ íŒŒì¼ì„ ì…ë ¥ìœ¼ë¡œ ë°›ì•„ ì‹¤ì‹œê°„ ì¶”ë¡ ì„ ì‹¤í–‰í•©ë‹ˆë‹¤.
"""

import os
import sys
import argparse
import logging
import cv2
import time
from pathlib import Path  # CROSS_PLATFORM_COMPATIBILITY í•„ìˆ˜
from typing import Optional

# í”„ë¡œì íŠ¸ ë£¨íŠ¸ ê²½ë¡œ ì¶”ê°€
project_root = Path(__file__).parent.parent.parent.parent
sys.path.append(str(project_root))

from common.logging import setup_logging
from common.config import load_config
from .model import {FeatureName}Model

def get_optimal_config():
    """í•˜ë“œì›¨ì–´ í™˜ê²½ì— ë”°ë¥¸ ìµœì  ì„¤ì • ìë™ ì„ íƒ"""
    import platform, psutil
    system = platform.system().lower()
    cpu_count = psutil.cpu_count()
    memory_gb = psutil.virtual_memory().total // (1024**3)
    
    try:
        import torch
        gpu_available = torch.cuda.is_available()
        gpu_memory = torch.cuda.get_device_properties(0).total_memory // (1024**3) if gpu_available else 0
    except:
        gpu_available = False
        gpu_memory = 0
    
    if gpu_available and gpu_memory >= 16:
        return {"device": "cuda", "batch_size": 16, "model_size": "large", "precision": "fp16"}
    elif gpu_available and gpu_memory >= 4:
        return {"device": "cuda", "batch_size": 4, "model_size": "medium", "precision": "fp16"}
    else:
        return {"device": "cpu", "batch_size": 1, "model_size": "small", "precision": "fp32"}

def is_jetson():
    """Jetson í™˜ê²½ ê°ì§€"""
    try:
        with open("/proc/device-tree/model", "r") as f:
            return "jetson" in f.read().lower()
    except:
        return False

def create_platform_camera(camera_id=0, config=None):
    """í”Œë«í¼ë³„ ì¹´ë©”ë¼ ìƒì„±"""
    import platform
    system = platform.system().lower()
    
    if system == "windows":
        cap = cv2.VideoCapture(camera_id, cv2.CAP_DSHOW)
        cap.set(cv2.CAP_PROP_FOURCC, cv2.VideoWriter_fourcc('M','J','P','G'))
    elif system == "linux":
        cap = cv2.VideoCapture(camera_id, cv2.CAP_V4L2)
        if is_jetson():
            cap.set(cv2.CAP_PROP_BUFFERSIZE, 1)
    else:
        cap = cv2.VideoCapture(camera_id)
    
    return cap

def parse_args():
    """ëª…ë ¹ì¤„ ì¸ì íŒŒì‹±"""
    parser = argparse.ArgumentParser(description="{feature_name} ì‹¤ì‹œê°„ ì¶”ë¡ ")
    parser.add_argument("--source", type=str, default="0", help="ì…ë ¥ ì†ŒìŠ¤ (ì¹´ë©”ë¼ ID, íŒŒì¼ ê²½ë¡œ)")
    parser.add_argument("--model", type=str, help="ëª¨ë¸ íŒŒì¼ ê²½ë¡œ")
    parser.add_argument("--config", type=str, help="ì„¤ì • íŒŒì¼ ê²½ë¡œ")
    parser.add_argument("--conf", type=float, default=0.5, help="ì‹ ë¢°ë„ ì„ê³„ê°’")
    parser.add_argument("--show", action="store_true", help="ê²°ê³¼ í™”ë©´ í‘œì‹œ")
    parser.add_argument("--save", action="store_true", help="ê²°ê³¼ ì €ì¥")
    return parser.parse_args()

def handle_keyboard_input():
    """í‚¤ë³´ë“œ ì…ë ¥ ì²˜ë¦¬"""
    key = cv2.waitKey(1) & 0xFF
    if key == ord('q'):
        return 'quit'
    elif key == ord('s'):
        return 'save_frame'
    elif key == ord('r'):
        return 'toggle_record'
    elif key == ord('p'):
        return 'toggle_pause'
    return None

def main():
    """ë©”ì¸ í•¨ìˆ˜"""
    args = parse_args()
    
    # ë¡œê¹… ì„¤ì •
    setup_logging()
    logger = logging.getLogger(__name__)
    
    # ì„¤ì • ë¡œë“œ
    config = load_config(args.config)
    
    try:
        # í•˜ë“œì›¨ì–´ ìµœì í™” ì„¤ì •
        optimal_config = get_optimal_config()
        logger.info(f"Optimal config: {optimal_config}")
        
        # ëª¨ë¸ ë¡œë”©
        model = {FeatureName}Model(args.model, config)
        
        # ì…ë ¥ ì†ŒìŠ¤ ì„¤ì •
        if args.source.isdigit():
            cap = create_platform_camera(int(args.source))
        else:
            cap = cv2.VideoCapture(args.source)
        
        if not cap.isOpened():
            logger.error(f"Cannot open source: {args.source}")
            return
        
        # ë©”ì¸ ì²˜ë¦¬ ë£¨í”„
        while True:
            ret, frame = cap.read()
            if not ret:
                break
            
            # ì¶”ë¡  ì‹¤í–‰
            start_time = time.time()
            results = model.predict(frame)
            processing_time = time.time() - start_time
            
            # ê²°ê³¼ ì‹œê°í™”
            if args.show:
                # TODO: ê²°ê³¼ ì‹œê°í™” êµ¬í˜„
                cv2.imshow('Result', frame)
                
                # í‚¤ë³´ë“œ ì…ë ¥ ì²˜ë¦¬
                action = handle_keyboard_input()
                if action == 'quit':
                    break
                elif action == 'save_frame':
                    output_path = project_root / "data" / "output" / f"frame_{int(time.time())}.jpg"
                    cv2.imwrite(str(output_path), frame)
                    logger.info(f"Frame saved: {output_path}")
        
        cap.release()
        cv2.destroyAllWindows()
        
    except KeyboardInterrupt:
        logger.info("Interrupted by user")
    except Exception as e:
        logger.error(f"Error: {e}")
        raise
    finally:
        logger.info("Finished {feature_name}")

if __name__ == "__main__":
    main()
```

## ğŸ“‹ ëˆ„ë½ëœ í´ë” ìƒì„± ê°€ì´ë“œ

### í˜„ì¬ ëˆ„ë½ëœ í´ë”ë“¤ (ìƒì„± í•„ìš”)
```python
MISSING_FOLDERS = {
    'config/': {
        'purpose': 'ì„¤ì • íŒŒì¼ ì €ì¥',
        'files': ['__init__.py', 'face_recognition.yaml', 'defect_detection.yaml']
    },
    'models/': {
        'purpose': 'ëª¨ë¸ ì €ì¥ì†Œ',
        'subfolders': ['weights/']  # .onnx íŒŒì¼ ì €ì¥
    },
    'datasets/': {
        'purpose': 'í•™ìŠµ ë°ì´í„° ì €ì¥',
        'subfolders': ['humanoid/', 'factory/']
    },
    'scripts/': {
        'purpose': 'ê°œë°œ ë„êµ¬ ìŠ¤í¬ë¦½íŠ¸',
        'files': ['setup_coding_tools.py', 'validate_rules.py']
    },
    'data/domains/': {
        'purpose': 'ë„ë©”ì¸ë³„ ëŸ°íƒ€ì„ ë°ì´í„°',
        'subfolders': ['humanoid/', 'factory/']
    },
    'shared/vision_core/': {
        'purpose': 'ë¹„ì „ ì•Œê³ ë¦¬ì¦˜ ê³µí†µ ê¸°ëŠ¥',
        'subfolders': ['detection/', 'recognition/', 'preprocessing/']
    }
}
```

### í´ë” ìƒì„± ìŠ¤í¬ë¦½íŠ¸ ì˜ˆì‹œ
```python
def create_missing_folders():
    """ëˆ„ë½ëœ í´ë”ë“¤ ìƒì„±"""
    from pathlib import Path
    
    missing_structure = {
        'config': ['__init__.py'],
        'models/weights': ['__init__.py'],
        'datasets/humanoid': ['__init__.py'],
        'datasets/factory': ['__init__.py'],
        'scripts': ['__init__.py'],
        'data/domains/humanoid': ['__init__.py'],
        'data/domains/factory': ['__init__.py'],
        'shared/vision_core/detection': ['__init__.py'],
        'shared/vision_core/recognition': ['__init__.py'],
        'shared/vision_core/preprocessing': ['__init__.py']
    }
    
    for folder_path, files in missing_structure.items():
        folder = Path(folder_path)
        folder.mkdir(parents=True, exist_ok=True)
        
        for file in files:
            file_path = folder / file
            if not file_path.exists():
                file_path.touch()
                print(f"Created: {file_path}")
```

## ğŸ¯ ê²°ë¡ 

ì´ í†µí•© ê°€ì´ë“œë¥¼ ë”°ë¼ ê°œë°œí•˜ë©´:

1. **CROSS_PLATFORM_COMPATIBILITY ê·œì¹™ì„ ìµœìš°ì„ ìœ¼ë¡œ ì¤€ìˆ˜**
2. **í˜„ì¬ í”„ë¡œì íŠ¸ êµ¬ì¡°ì— ë§ëŠ” ì¼ê´€ëœ ê°œë°œ í™˜ê²½ êµ¬ì¶•**
3. **ë‹¤ë¥¸ ê·œì¹™ë“¤ì˜ ì¥ì ë„ í™œìš©**
4. **ëª¨ìˆœì  ì—†ì´ í™•ì¥ ê°€ëŠ¥í•œ êµ¬ì¡° ìœ ì§€**
5. **í¬ë¡œìŠ¤ í”Œë«í¼ í˜¸í™˜ì„± ë³´ì¥**

ëª¨ë“  ìƒˆë¡œìš´ ê¸°ëŠ¥ ê°œë°œ ì‹œ ì´ ê°€ì´ë“œë¥¼ ì°¸ì¡°í•˜ì—¬ ì¼ê´€ì„± ìˆëŠ” ì½”ë“œë¥¼ ì‘ì„±í•˜ì„¸ìš”.



