---
description: 
globs: 
alwaysApply: false
---
# ë¬¸ì„œí™” ì‹œìŠ¤í…œ ê·œì¹™ (Documentation System Rules)

ì´ ê·œì¹™ì€ ìë™ ë¬¸ì„œí™”, API ë¬¸ì„œ ìƒì„±, ì½”ë“œ ë¬¸ì„œí™”, ì‚¬ìš©ì ê°€ì´ë“œ ì‘ì„±ì— ê´€í•œ ë²”ìš© í‘œì¤€ì…ë‹ˆë‹¤.

## ğŸ“š ìë™ API ë¬¸ì„œ ìƒì„±

### FastAPI + Swagger í†µí•©
```python
from fastapi import FastAPI, HTTPException, Depends, status
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import HTMLResponse
from fastapi.openapi.docs import get_swagger_ui_html
from fastapi.openapi.utils import get_openapi
from pydantic import BaseModel, Field
from typing import List, Optional, Dict, Any
import uvicorn

app = FastAPI(
    title="Vision System API",
    description="""
    ## Vision System API Documentation
    
    ì´ APIëŠ” ë¹„ì „ ì‹œìŠ¤í…œì˜ í•µì‹¬ ê¸°ëŠ¥ì„ ì œê³µí•©ë‹ˆë‹¤:
    
    * **ì¹´ë©”ë¼ ê´€ë¦¬** - ì¹´ë©”ë¼ ì—°ê²°, ì„¤ì •, ëª¨ë‹ˆí„°ë§
    * **ì´ë¯¸ì§€ ì²˜ë¦¬** - ì‹¤ì‹œê°„ ì´ë¯¸ì§€ ë¶„ì„ ë° ì²˜ë¦¬
    * **ëª¨ë¸ ê´€ë¦¬** - AI ëª¨ë¸ ë¡œë”©, ì¶”ë¡ , ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§
    * **ê²°ê³¼ ì¡°íšŒ** - ë¶„ì„ ê²°ê³¼ ì¡°íšŒ ë° í†µê³„
    
    ### ì¸ì¦
    ëª¨ë“  API ì—”ë“œí¬ì¸íŠ¸ëŠ” JWT í† í° ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤.
    
    ### ìš”ì²­ ì œí•œ
    - ì¼ë°˜ ì‚¬ìš©ì: ì‹œê°„ë‹¹ 100íšŒ
    - ê´€ë¦¬ì: ì‹œê°„ë‹¹ 1000íšŒ
    """,
    version="1.0.0",
    contact={
        "name": "Vision System Team",
        "email": "vision-team@company.com",
        "url": "https://github.com/company/vision-system"
    },
    license_info={
        "name": "MIT License",
        "url": "https://opensource.org/licenses/MIT"
    },
    openapi_tags=[
        {
            "name": "cameras",
            "description": "ì¹´ë©”ë¼ ê´€ë¦¬ ê´€ë ¨ API",
        },
        {
            "name": "models",
            "description": "AI ëª¨ë¸ ê´€ë¦¬ ê´€ë ¨ API",
        },
        {
            "name": "processing",
            "description": "ì´ë¯¸ì§€ ì²˜ë¦¬ ê´€ë ¨ API",
        },
        {
            "name": "monitoring",
            "description": "ì‹œìŠ¤í…œ ëª¨ë‹ˆí„°ë§ ê´€ë ¨ API",
        }
    ]
)

# Pydantic ëª¨ë¸ ì •ì˜ (ìë™ ìŠ¤í‚¤ë§ˆ ìƒì„±)
class CameraConfig(BaseModel):
    """ì¹´ë©”ë¼ ì„¤ì • ëª¨ë¸"""
    
    camera_id: str = Field(
        ..., 
        description="ì¹´ë©”ë¼ ê³ ìœ  ì‹ë³„ì",
        example="camera_001"
    )
    rtsp_url: str = Field(
        ..., 
        description="RTSP ìŠ¤íŠ¸ë¦¼ URL",
        example="rtsp://192.168.1.100:554/stream1"
    )
    resolution: str = Field(
        default="1920x1080",
        description="í•´ìƒë„ ì„¤ì •",
        example="1920x1080"
    )
    fps: int = Field(
        default=30,
        ge=1,
        le=60,
        description="ì´ˆë‹¹ í”„ë ˆì„ ìˆ˜ (1-60)",
        example=30
    )
    enabled: bool = Field(
        default=True,
        description="ì¹´ë©”ë¼ í™œì„±í™” ì—¬ë¶€"
    )
    
    class Config:
        schema_extra = {
            "example": {
                "camera_id": "camera_001",
                "rtsp_url": "rtsp://192.168.1.100:554/stream1",
                "resolution": "1920x1080",
                "fps": 30,
                "enabled": True
            }
        }

class DetectionResult(BaseModel):
    """ê²€ì¶œ ê²°ê³¼ ëª¨ë¸"""
    
    detection_id: str = Field(..., description="ê²€ì¶œ ê²°ê³¼ ê³ ìœ  ID")
    camera_id: str = Field(..., description="ì¹´ë©”ë¼ ID")
    timestamp: float = Field(..., description="ê²€ì¶œ ì‹œê°„ (Unix timestamp)")
    class_name: str = Field(..., description="ê²€ì¶œëœ ê°ì²´ í´ë˜ìŠ¤")
    confidence: float = Field(
        ..., 
        ge=0.0, 
        le=1.0, 
        description="ì‹ ë¢°ë„ (0.0-1.0)"
    )
    bbox: List[float] = Field(
        ..., 
        description="ë°”ìš´ë”© ë°•ìŠ¤ [x, y, width, height]",
        min_items=4,
        max_items=4
    )
    metadata: Optional[Dict[str, Any]] = Field(
        default=None,
        description="ì¶”ê°€ ë©”íƒ€ë°ì´í„°"
    )

class APIResponse(BaseModel):
    """í‘œì¤€ API ì‘ë‹µ ëª¨ë¸"""
    
    success: bool = Field(..., description="ìš”ì²­ ì„±ê³µ ì—¬ë¶€")
    message: str = Field(..., description="ì‘ë‹µ ë©”ì‹œì§€")
    data: Optional[Any] = Field(default=None, description="ì‘ë‹µ ë°ì´í„°")
    error_code: Optional[str] = Field(default=None, description="ì—ëŸ¬ ì½”ë“œ")

# API ì—”ë“œí¬ì¸íŠ¸ ì •ì˜
@app.post(
    "/cameras/",
    response_model=APIResponse,
    tags=["cameras"],
    summary="ì¹´ë©”ë¼ ì¶”ê°€",
    description="ìƒˆë¡œìš´ ì¹´ë©”ë¼ë¥¼ ì‹œìŠ¤í…œì— ì¶”ê°€í•©ë‹ˆë‹¤.",
    responses={
        201: {
            "description": "ì¹´ë©”ë¼ê°€ ì„±ê³µì ìœ¼ë¡œ ì¶”ê°€ë¨",
            "content": {
                "application/json": {
                    "example": {
                        "success": True,
                        "message": "Camera added successfully",
                        "data": {"camera_id": "camera_001"}
                    }
                }
            }
        },
        400: {
            "description": "ì˜ëª»ëœ ìš”ì²­",
            "content": {
                "application/json": {
                    "example": {
                        "success": False,
                        "message": "Invalid camera configuration",
                        "error_code": "INVALID_CONFIG"
                    }
                }
            }
        }
    }
)
async def add_camera(camera_config: CameraConfig):
    """
    ì¹´ë©”ë¼ë¥¼ ì‹œìŠ¤í…œì— ì¶”ê°€í•©ë‹ˆë‹¤.
    
    - **camera_id**: ì¹´ë©”ë¼ì˜ ê³ ìœ  ì‹ë³„ì
    - **rtsp_url**: ì¹´ë©”ë¼ì˜ RTSP ìŠ¤íŠ¸ë¦¼ URL
    - **resolution**: í•´ìƒë„ ì„¤ì • (ì˜ˆ: 1920x1080)
    - **fps**: ì´ˆë‹¹ í”„ë ˆì„ ìˆ˜ (1-60 ë²”ìœ„)
    - **enabled**: ì¹´ë©”ë¼ í™œì„±í™” ì—¬ë¶€
    
    Returns:
        APIResponse: ì¹´ë©”ë¼ ì¶”ê°€ ê²°ê³¼
    """
    try:
        # ì¹´ë©”ë¼ ì¶”ê°€ ë¡œì§
        result = camera_manager.add_camera(camera_config)
        return APIResponse(
            success=True,
            message="Camera added successfully",
            data={"camera_id": camera_config.camera_id}
        )
    except Exception as e:
        raise HTTPException(
            status_code=400,
            detail={
                "success": False,
                "message": str(e),
                "error_code": "CAMERA_ADD_FAILED"
            }
        )

@app.get(
    "/cameras/{camera_id}/detections",
    response_model=List[DetectionResult],
    tags=["processing"],
    summary="ê²€ì¶œ ê²°ê³¼ ì¡°íšŒ",
    description="íŠ¹ì • ì¹´ë©”ë¼ì˜ ê²€ì¶œ ê²°ê³¼ë¥¼ ì¡°íšŒí•©ë‹ˆë‹¤."
)
async def get_detections(
    camera_id: str = Field(..., description="ì¹´ë©”ë¼ ID"),
    limit: int = Field(default=100, ge=1, le=1000, description="ê²°ê³¼ ê°œìˆ˜ ì œí•œ"),
    start_time: Optional[float] = Field(default=None, description="ì‹œì‘ ì‹œê°„ (Unix timestamp)"),
    end_time: Optional[float] = Field(default=None, description="ì¢…ë£Œ ì‹œê°„ (Unix timestamp)")
):
    """
    íŠ¹ì • ì¹´ë©”ë¼ì˜ ê²€ì¶œ ê²°ê³¼ë¥¼ ì¡°íšŒí•©ë‹ˆë‹¤.
    
    Args:
        camera_id: ì¹´ë©”ë¼ ê³ ìœ  ì‹ë³„ì
        limit: ë°˜í™˜í•  ê²°ê³¼ì˜ ìµœëŒ€ ê°œìˆ˜ (1-1000)
        start_time: ì¡°íšŒ ì‹œì‘ ì‹œê°„ (Unix timestamp)
        end_time: ì¡°íšŒ ì¢…ë£Œ ì‹œê°„ (Unix timestamp)
    
    Returns:
        List[DetectionResult]: ê²€ì¶œ ê²°ê³¼ ëª©ë¡
    """
    try:
        results = detection_service.get_detections(
            camera_id=camera_id,
            limit=limit,
            start_time=start_time,
            end_time=end_time
        )
        return results
    except Exception as e:
        raise HTTPException(status_code=404, detail=str(e))

# ì»¤ìŠ¤í…€ OpenAPI ìŠ¤í‚¤ë§ˆ
def custom_openapi():
    if app.openapi_schema:
        return app.openapi_schema
    
    openapi_schema = get_openapi(
        title=app.title,
        version=app.version,
        description=app.description,
        routes=app.routes,
    )
    
    # ì»¤ìŠ¤í…€ ìŠ¤í‚¤ë§ˆ í™•ì¥
    openapi_schema["info"]["x-logo"] = {
        "url": "https://company.com/logo.png"
    }
    
    # ë³´ì•ˆ ìŠ¤í‚¤ë§ˆ ì¶”ê°€
    openapi_schema["components"]["securitySchemes"] = {
        "BearerAuth": {
            "type": "http",
            "scheme": "bearer",
            "bearerFormat": "JWT"
        }
    }
    
    # ì „ì—­ ë³´ì•ˆ ì ìš©
    openapi_schema["security"] = [{"BearerAuth": []}]
    
    app.openapi_schema = openapi_schema
    return app.openapi_schema

app.openapi = custom_openapi
```

## ğŸ“– Sphinx ë¬¸ì„œí™” ì‹œìŠ¤í…œ

### Sphinx ì„¤ì •
```python
# docs/conf.py
import os
import sys
sys.path.insert(0, os.path.abspath('..'))

# í”„ë¡œì íŠ¸ ì •ë³´
project = 'Vision System'
copyright = '2025, Vision Team'
author = 'Vision Team'
version = '1.0.0'
release = '1.0.0'

# í™•ì¥ ê¸°ëŠ¥
extensions = [
    'sphinx.ext.autodoc',          # ìë™ ë¬¸ì„œ ìƒì„±
    'sphinx.ext.viewcode',         # ì†ŒìŠ¤ ì½”ë“œ ë§í¬
    'sphinx.ext.napoleon',         # Google/NumPy ìŠ¤íƒ€ì¼ docstring
    'sphinx.ext.intersphinx',      # ì™¸ë¶€ ë¬¸ì„œ ë§í¬
    'sphinx.ext.todo',             # TODO í•­ëª©
    'sphinx.ext.coverage',         # ë¬¸ì„œí™” ì»¤ë²„ë¦¬ì§€
    'sphinx.ext.githubpages',      # GitHub Pages ì§€ì›
    'sphinx_rtd_theme',            # Read the Docs í…Œë§ˆ
    'sphinxcontrib.mermaid',       # Mermaid ë‹¤ì´ì–´ê·¸ë¨
    'sphinx_copybutton',           # ì½”ë“œ ë³µì‚¬ ë²„íŠ¼
]

# í…œí”Œë¦¿ ê²½ë¡œ
templates_path = ['_templates']

# ì œì™¸í•  íŒ¨í„´
exclude_patterns = ['_build', 'Thumbs.db', '.DS_Store']

# HTML ì¶œë ¥ ì„¤ì •
html_theme = 'sphinx_rtd_theme'
html_static_path = ['_static']
html_css_files = ['custom.css']

# í…Œë§ˆ ì˜µì…˜
html_theme_options = {
    'canonical_url': '',
    'analytics_id': 'UA-XXXXXXX-1',
    'logo_only': False,
    'display_version': True,
    'prev_next_buttons_location': 'bottom',
    'style_external_links': False,
    'vcs_pageview_mode': '',
    'style_nav_header_background': '#2980B9',
    'collapse_navigation': True,
    'sticky_navigation': True,
    'navigation_depth': 4,
    'includehidden': True,
    'titles_only': False
}

# autodoc ì„¤ì •
autodoc_default_options = {
    'members': True,
    'member-order': 'bysource',
    'special-members': '__init__',
    'undoc-members': True,
    'exclude-members': '__weakref__'
}

# Napoleon ì„¤ì • (Google ìŠ¤íƒ€ì¼ docstring)
napoleon_google_docstring = True
napoleon_numpy_docstring = True
napoleon_include_init_with_doc = False
napoleon_include_private_with_doc = False
napoleon_include_special_with_doc = True
napoleon_use_admonition_for_examples = False
napoleon_use_admonition_for_notes = False
napoleon_use_admonition_for_references = False
napoleon_use_ivar = False
napoleon_use_param = True
napoleon_use_rtype = True

# Intersphinx ë§¤í•‘
intersphinx_mapping = {
    'python': ('https://docs.python.org/3/', None),
    'numpy': ('https://numpy.org/doc/stable/', None),
    'opencv': ('https://docs.opencv.org/4.x/', None),
    'fastapi': ('https://fastapi.tiangolo.com/', None),
}

# TODO í™•ì¥ ì„¤ì •
todo_include_todos = True

# ì»¤ë²„ë¦¬ì§€ ì„¤ì •
coverage_show_missing_items = True
```

### ìë™ ë¬¸ì„œ ìƒì„± ìŠ¤í¬ë¦½íŠ¸
```python
# scripts/generate_docs.py
import os
import subprocess
import shutil
from pathlib import Path
import ast
import inspect
from typing import List, Dict, Any

class DocumentationGenerator:
    """ìë™ ë¬¸ì„œ ìƒì„±ê¸°"""
    
    def __init__(self, source_dir: str = "src", docs_dir: str = "docs"):
        self.source_dir = Path(source_dir)
        self.docs_dir = Path(docs_dir)
        self.api_docs_dir = self.docs_dir / "api"
        
    def generate_all_docs(self):
        """ëª¨ë“  ë¬¸ì„œ ìƒì„±"""
        print("ğŸš€ Starting documentation generation...")
        
        # 1. API ë¬¸ì„œ ìƒì„±
        self.generate_api_docs()
        
        # 2. ì‚¬ìš©ì ê°€ì´ë“œ ìƒì„±
        self.generate_user_guides()
        
        # 3. ê°œë°œì ê°€ì´ë“œ ìƒì„±
        self.generate_developer_guides()
        
        # 4. Sphinx ë¹Œë“œ
        self.build_sphinx_docs()
        
        print("âœ… Documentation generation completed!")
    
    def generate_api_docs(self):
        """API ë¬¸ì„œ ìë™ ìƒì„±"""
        print("ğŸ“š Generating API documentation...")
        
        # API ë¬¸ì„œ ë””ë ‰í† ë¦¬ ìƒì„±
        self.api_docs_dir.mkdir(parents=True, exist_ok=True)
        
        # ëª¨ë“  Python ëª¨ë“ˆ ìŠ¤ìº”
        for py_file in self.source_dir.rglob("*.py"):
            if py_file.name == "__init__.py":
                continue
                
            module_path = str(py_file.relative_to(self.source_dir)).replace("/", ".").replace("\\", ".")[:-3]
            self._generate_module_doc(module_path, py_file)
    
    def _generate_module_doc(self, module_path: str, file_path: Path):
        """ê°œë³„ ëª¨ë“ˆ ë¬¸ì„œ ìƒì„±"""
        try:
            # ASTë¥¼ ì‚¬ìš©í•œ ëª¨ë“ˆ ë¶„ì„
            with open(file_path, 'r', encoding='utf-8') as f:
                source = f.read()
            
            tree = ast.parse(source)
            module_info = self._analyze_module(tree)
            
            # RST íŒŒì¼ ìƒì„±
            rst_content = self._generate_rst_content(module_path, module_info)
            
            rst_file = self.api_docs_dir / f"{module_path.replace('.', '_')}.rst"
            with open(rst_file, 'w', encoding='utf-8') as f:
                f.write(rst_content)
                
        except Exception as e:
            print(f"âš ï¸  Error processing {module_path}: {str(e)}")
    
    def _analyze_module(self, tree: ast.AST) -> Dict[str, Any]:
        """ëª¨ë“ˆ AST ë¶„ì„"""
        module_info = {
            'docstring': ast.get_docstring(tree),
            'classes': [],
            'functions': [],
            'constants': []
        }
        
        for node in ast.walk(tree):
            if isinstance(node, ast.ClassDef):
                class_info = {
                    'name': node.name,
                    'docstring': ast.get_docstring(node),
                    'methods': []
                }
                
                for item in node.body:
                    if isinstance(item, ast.FunctionDef):
                        method_info = {
                            'name': item.name,
                            'docstring': ast.get_docstring(item),
                            'args': [arg.arg for arg in item.args.args]
                        }
                        class_info['methods'].append(method_info)
                
                module_info['classes'].append(class_info)
            
            elif isinstance(node, ast.FunctionDef) and not any(
                isinstance(parent, ast.ClassDef) 
                for parent in ast.walk(tree) 
                if node in getattr(parent, 'body', [])
            ):
                func_info = {
                    'name': node.name,
                    'docstring': ast.get_docstring(node),
                    'args': [arg.arg for arg in node.args.args]
                }
                module_info['functions'].append(func_info)
        
        return module_info
    
    def _generate_rst_content(self, module_path: str, module_info: Dict) -> str:
        """RST ë‚´ìš© ìƒì„±"""
        lines = []
        
        # ì œëª©
        title = f"{module_path} Module"
        lines.append(title)
        lines.append("=" * len(title))
        lines.append("")
        
        # ëª¨ë“ˆ docstring
        if module_info['docstring']:
            lines.append(module_info['docstring'])
            lines.append("")
        
        # automodule ì§€ì‹œë¬¸
        lines.append(f".. automodule:: {module_path}")
        lines.append("   :members:")
        lines.append("   :undoc-members:")
        lines.append("   :show-inheritance:")
        lines.append("")
        
        # í´ë˜ìŠ¤ ìƒì„¸ ì •ë³´
        if module_info['classes']:
            lines.append("Classes")
            lines.append("-------")
            lines.append("")
            
            for class_info in module_info['classes']:
                lines.append(f".. autoclass:: {module_path}.{class_info['name']}")
                lines.append("   :members:")
                lines.append("   :undoc-members:")
                lines.append("   :show-inheritance:")
                lines.append("")
        
        # í•¨ìˆ˜ ìƒì„¸ ì •ë³´
        if module_info['functions']:
            lines.append("Functions")
            lines.append("---------")
            lines.append("")
            
            for func_info in module_info['functions']:
                lines.append(f".. autofunction:: {module_path}.{func_info['name']}")
                lines.append("")
        
        return "\n".join(lines)
    
    def generate_user_guides(self):
        """ì‚¬ìš©ì ê°€ì´ë“œ ìƒì„±"""
        print("ğŸ“– Generating user guides...")
        
        guides = {
            "installation": self._generate_installation_guide(),
            "quickstart": self._generate_quickstart_guide(),
            "configuration": self._generate_configuration_guide(),
            "troubleshooting": self._generate_troubleshooting_guide()
        }
        
        for guide_name, content in guides.items():
            guide_file = self.docs_dir / f"{guide_name}.rst"
            with open(guide_file, 'w', encoding='utf-8') as f:
                f.write(content)
    
    def _generate_installation_guide(self) -> str:
        """ì„¤ì¹˜ ê°€ì´ë“œ ìƒì„±"""
        return """
Installation Guide
==================

System Requirements
-------------------

* Python 3.8 or higher
* CUDA 11.8+ (for GPU support)
* OpenCV 4.5+
* 8GB+ RAM (16GB+ recommended)

Installation Steps
------------------

1. Clone the repository:

.. code-block:: bash

   git clone https://github.com/company/vision-system.git
   cd vision-system

2. Create virtual environment:

.. code-block:: bash

   python -m venv venv
   source venv/bin/activate  # On Windows: venv\\Scripts\\activate

3. Install dependencies:

.. code-block:: bash

   pip install -r requirements.txt

4. Download models:

.. code-block:: bash

   python scripts/download_models.py

5. Configure settings:

.. code-block:: bash

   cp config/config.yaml.example config/config.yaml
   # Edit config.yaml with your settings

Verification
------------

Run the test suite to verify installation:

.. code-block:: bash

   pytest tests/

Start the API server:

.. code-block:: bash

   python -m src.main

Visit http://localhost:8000/docs to see the API documentation.
"""
    
    def _generate_quickstart_guide(self) -> str:
        """í€µìŠ¤íƒ€íŠ¸ ê°€ì´ë“œ ìƒì„±"""
        return """
Quickstart Guide
================

This guide will help you get started with the Vision System in 5 minutes.

Basic Usage
-----------

1. Start the API server:

.. code-block:: bash

   python -m src.main

2. Add a camera:

.. code-block:: python

   import requests
   
   camera_config = {
       "camera_id": "cam001",
       "rtsp_url": "rtsp://192.168.1.100:554/stream1",
       "resolution": "1920x1080",
       "fps": 30,
       "enabled": True
   }
   
   response = requests.post(
       "http://localhost:8000/cameras/",
       json=camera_config
   )

3. Start processing:

.. code-block:: python

   response = requests.post(
       f"http://localhost:8000/cameras/{camera_id}/start"
   )

4. Get detection results:

.. code-block:: python

   response = requests.get(
       f"http://localhost:8000/cameras/{camera_id}/detections"
   )
   detections = response.json()

Example Application
-------------------

Here's a complete example:

.. code-block:: python

   from src.camera_manager import CameraManager
   from src.vision_processor import VisionProcessor
   
   # Initialize components
   camera_manager = CameraManager()
   processor = VisionProcessor()
   
   # Add camera
   camera_manager.add_camera("cam001", "rtsp://...")
   
   # Start processing
   processor.start_processing("cam001")
   
   # Get results
   results = processor.get_latest_results("cam001")
   print(f"Detected {len(results)} objects")

Next Steps
----------

* Read the :doc:`configuration` guide for advanced settings
* Check out the :doc:`api/index` for complete API reference
* See :doc:`examples/index` for more examples
"""
    
    def generate_developer_guides(self):
        """ê°œë°œì ê°€ì´ë“œ ìƒì„±"""
        print("ğŸ”§ Generating developer guides...")
        
        # ê°œë°œ í™˜ê²½ ì„¤ì • ê°€ì´ë“œ
        dev_guide = """
Developer Guide
===============

Development Environment Setup
-----------------------------

1. Install development dependencies:

.. code-block:: bash

   pip install -r requirements-dev.txt

2. Set up pre-commit hooks:

.. code-block:: bash

   pre-commit install

3. Run tests:

.. code-block:: bash

   pytest tests/ --cov=src

Code Style
----------

We use the following tools for code quality:

* **Black** for code formatting
* **isort** for import sorting
* **flake8** for linting
* **mypy** for type checking

Run all checks:

.. code-block:: bash

   make lint

Architecture Overview
--------------------

.. mermaid::

   graph TD
       A[API Server] --> B[Camera Manager]
       A --> C[Vision Processor]
       A --> D[Model Manager]
       B --> E[Camera Streams]
       C --> F[AI Models]
       D --> G[Model Storage]

Contributing
------------

1. Fork the repository
2. Create a feature branch
3. Make your changes
4. Add tests
5. Submit a pull request

Testing Guidelines
------------------

* Write unit tests for all new functions
* Include integration tests for API endpoints
* Maintain >90% code coverage
* Use pytest fixtures for common test data
"""
        
        dev_file = self.docs_dir / "development.rst"
        with open(dev_file, 'w', encoding='utf-8') as f:
            f.write(dev_guide)
    
    def build_sphinx_docs(self):
        """Sphinx ë¬¸ì„œ ë¹Œë“œ"""
        print("ğŸ—ï¸  Building Sphinx documentation...")
        
        try:
            # Sphinx ë¹Œë“œ ì‹¤í–‰
            subprocess.run([
                "sphinx-build", 
                "-b", "html", 
                str(self.docs_dir), 
                str(self.docs_dir / "_build" / "html")
            ], check=True)
            
            print("âœ… Sphinx documentation built successfully!")
            print(f"ğŸ“„ Documentation available at: {self.docs_dir / '_build' / 'html' / 'index.html'}")
            
        except subprocess.CalledProcessError as e:
            print(f"âŒ Sphinx build failed: {str(e)}")

if __name__ == "__main__":
    generator = DocumentationGenerator()
    generator.generate_all_docs()
```

## ğŸ“‹ README ìë™ ìƒì„±

### README í…œí”Œë¦¿ ì‹œìŠ¤í…œ
```python
# scripts/generate_readme.py
import yaml
import json
from pathlib import Path
from typing import Dict, List, Any

class ReadmeGenerator:
    """README.md ìë™ ìƒì„±ê¸°"""
    
    def __init__(self, config_file: str = "docs/readme_config.yaml"):
        self.config_file = Path(config_file)
        self.config = self._load_config()
        
    def _load_config(self) -> Dict[str, Any]:
        """ì„¤ì • íŒŒì¼ ë¡œë“œ"""
        with open(self.config_file, 'r', encoding='utf-8') as f:
            return yaml.safe_load(f)
    
    def generate_readme(self) -> str:
        """README.md ë‚´ìš© ìƒì„±"""
        sections = []
        
        # í—¤ë”
        sections.append(self._generate_header())
        
        # ë°°ì§€
        sections.append(self._generate_badges())
        
        # ëª©ì°¨
        sections.append(self._generate_toc())
        
        # ì£¼ìš” ì„¹ì…˜ë“¤
        for section_name in self.config.get('sections', []):
            section_content = self._generate_section(section_name)
            if section_content:
                sections.append(section_content)
        
        return "\n\n".join(sections)
    
    def _generate_header(self) -> str:
        """í—¤ë” ì„¹ì…˜ ìƒì„±"""
        project = self.config['project']
        
        header = f"# {project['name']}\n\n"
        
        if project.get('logo'):
            header += f"![Logo](mdc:{project['logo']})\n\n"
        
        header += f"{project['description']}\n\n"
        
        if project.get('demo_gif'):
            header += f"![Demo](mdc:{project['demo_gif']})\n\n"
        
        return header.strip()
    
    def _generate_badges(self) -> str:
        """ë°°ì§€ ì„¹ì…˜ ìƒì„±"""
        badges = self.config.get('badges', [])
        if not badges:
            return ""
        
        badge_lines = []
        for badge in badges:
            badge_md = f"[![{badge['alt']}]({badge['image']})]({badge.get('link', '#')})"
            badge_lines.append(badge_md)
        
        return " ".join(badge_lines)
    
    def _generate_toc(self) -> str:
        """ëª©ì°¨ ìƒì„±"""
        sections = self.config.get('sections', [])
        if not sections:
            return ""
        
        toc_lines = ["## ğŸ“‹ Table of Contents", ""]
        
        for section in sections:
            section_config = self.config.get('section_configs', {}).get(section, {})
            title = section_config.get('title', section.replace('_', ' ').title())
            anchor = section.replace('_', '-').lower()
            toc_lines.append(f"- [{title}](mdc:#{anchor})")
        
        return "\n".join(toc_lines)
    
    def _generate_section(self, section_name: str) -> str:
        """ê°œë³„ ì„¹ì…˜ ìƒì„±"""
        method_name = f"_generate_{section_name}_section"
        
        if hasattr(self, method_name):
            return getattr(self, method_name)()
        else:
            return self._generate_generic_section(section_name)
    
    def _generate_features_section(self) -> str:
        """ê¸°ëŠ¥ ì„¹ì…˜ ìƒì„±"""
        features = self.config.get('features', [])
        if not features:
            return ""
        
        lines = ["## âœ¨ Features", ""]
        
        for feature in features:
            lines.append(f"- **{feature['name']}**: {feature['description']}")
        
        return "\n".join(lines)
    
    def _generate_installation_section(self) -> str:
        """ì„¤ì¹˜ ì„¹ì…˜ ìƒì„±"""
        installation = self.config.get('installation', {})
        if not installation:
            return ""
        
        lines = ["## ğŸš€ Installation", ""]
        
        # ì‹œìŠ¤í…œ ìš”êµ¬ì‚¬í•­
        if installation.get('requirements'):
            lines.extend([
                "### System Requirements",
                ""
            ])
            for req in installation['requirements']:
                lines.append(f"- {req}")
            lines.append("")
        
        # ì„¤ì¹˜ ë‹¨ê³„
        if installation.get('steps'):
            lines.extend([
                "### Installation Steps",
                ""
            ])
            for i, step in enumerate(installation['steps'], 1):
                lines.extend([
                    f"{i}. {step['description']}",
                    "",
                    "```bash",
                    step['command'],
                    "```",
                    ""
                ])
        
        return "\n".join(lines)
    
    def _generate_usage_section(self) -> str:
        """ì‚¬ìš©ë²• ì„¹ì…˜ ìƒì„±"""
        usage = self.config.get('usage', {})
        if not usage:
            return ""
        
        lines = ["## ğŸ“– Usage", ""]
        
        # ë¹ ë¥¸ ì‹œì‘
        if usage.get('quick_start'):
            lines.extend([
                "### Quick Start",
                "",
                "```python",
                usage['quick_start'],
                "```",
                ""
            ])
        
        # API ì˜ˆì œ
        if usage.get('api_examples'):
            lines.extend([
                "### API Examples",
                ""
            ])
            for example in usage['api_examples']:
                lines.extend([
                    f"#### {example['title']}",
                    "",
                    example.get('description', ''),
                    "",
                    f"```{example.get('language', 'python')}",
                    example['code'],
                    "```",
                    ""
                ])
        
        return "\n".join(lines)
    
    def _generate_api_section(self) -> str:
        """API ì„¹ì…˜ ìƒì„±"""
        api_config = self.config.get('api', {})
        if not api_config:
            return ""
        
        lines = ["## ğŸ”Œ API Reference", ""]
        
        if api_config.get('base_url'):
            lines.extend([
                f"**Base URL**: `{api_config['base_url']}`",
                ""
            ])
        
        if api_config.get('endpoints'):
            lines.extend([
                "### Endpoints",
                ""
            ])
            
            for endpoint in api_config['endpoints']:
                lines.extend([
                    f"#### {endpoint['method']} {endpoint['path']}",
                    "",
                    endpoint.get('description', ''),
                    ""
                ])
                
                if endpoint.get('example'):
                    lines.extend([
                        "**Example:**",
                        "",
                        "```bash",
                        endpoint['example'],
                        "```",
                        ""
                    ])
        
        if api_config.get('docs_url'):
            lines.extend([
                f"ğŸ“š [Complete API Documentation](mdc:{api_config['docs_url']})",
                ""
            ])
        
        return "\n".join(lines)
    
    def _generate_contributing_section(self) -> str:
        """ê¸°ì—¬ ê°€ì´ë“œ ì„¹ì…˜ ìƒì„±"""
        contributing = self.config.get('contributing', {})
        if not contributing:
            return ""
        
        lines = ["## ğŸ¤ Contributing", ""]
        
        lines.extend([
            "We welcome contributions! Please see our [Contributing Guide](mdc:CONTRIBUTING.md) for details.",
            "",
            "### Development Setup",
            "",
            "```bash",
            "git clone https://github.com/company/vision-system.git",
            "cd vision-system",
            "pip install -r requirements-dev.txt",
            "pre-commit install",
            "```",
            "",
            "### Running Tests",
            "",
            "```bash",
            "pytest tests/ --cov=src",
            "```",
            ""
        ])
        
        return "\n".join(lines)
    
    def _generate_license_section(self) -> str:
        """ë¼ì´ì„¼ìŠ¤ ì„¹ì…˜ ìƒì„±"""
        license_info = self.config.get('license', {})
        if not license_info:
            return ""
        
        lines = ["## ğŸ“„ License", ""]
        
        if license_info.get('name'):
            lines.append(f"This project is licensed under the {license_info['name']}.")
        
        if license_info.get('file'):
            lines.append(f"See the [LICENSE](mdc:{license_info['file']}) file for details.")
        
        return "\n".join(lines)
    
    def _generate_generic_section(self, section_name: str) -> str:
        """ì¼ë°˜ ì„¹ì…˜ ìƒì„±"""
        section_config = self.config.get('section_configs', {}).get(section_name, {})
        
        if not section_config:
            return ""
        
        title = section_config.get('title', section_name.replace('_', ' ').title())
        content = section_config.get('content', '')
        
        return f"## {title}\n\n{content}"

# README ì„¤ì • íŒŒì¼ ì˜ˆì œ
readme_config_example = """
project:
  name: "Vision System"
  description: "Advanced computer vision system for real-time object detection and analysis"
  logo: "docs/images/logo.png"
  demo_gif: "docs/images/demo.gif"

badges:
  - alt: "Build Status"
    image: "https://github.com/company/vision-system/workflows/CI/badge.svg"
    link: "https://github.com/company/vision-system/actions"
  - alt: "Coverage"
    image: "https://codecov.io/gh/company/vision-system/branch/main/graph/badge.svg"
    link: "https://codecov.io/gh/company/vision-system"
  - alt: "License"
    image: "https://img.shields.io/badge/license-MIT-blue.svg"
    link: "LICENSE"

sections:
  - features
  - installation
  - usage
  - api
  - contributing
  - license

features:
  - name: "Real-time Processing"
    description: "Process video streams in real-time with optimized performance"
  - name: "Multi-camera Support"
    description: "Manage multiple camera feeds simultaneously"
  - name: "AI Model Integration"
    description: "Easy integration with various AI models (YOLO, RCNN, etc.)"
  - name: "RESTful API"
    description: "Complete REST API for system integration"

installation:
  requirements:
    - "Python 3.8+"
    - "CUDA 11.8+ (for GPU support)"
    - "OpenCV 4.5+"
    - "8GB+ RAM"
  
  steps:
    - description: "Clone the repository"
      command: "git clone https://github.com/company/vision-system.git"
    - description: "Install dependencies"
      command: "pip install -r requirements.txt"
    - description: "Download models"
      command: "python scripts/download_models.py"

usage:
  quick_start: |
    from src.vision_system import VisionSystem
    
    # Initialize system
    vs = VisionSystem()
    
    # Add camera
    vs.add_camera("cam1", "rtsp://192.168.1.100/stream")
    
    # Start processing
    vs.start_processing("cam1")
    
    # Get results
    results = vs.get_detections("cam1")
  
  api_examples:
    - title: "Add Camera"
      description: "Add a new camera to the system"
      language: "bash"
      code: |
        curl -X POST "http://localhost:8000/cameras/" \\
             -H "Content-Type: application/json" \\
             -d '{"camera_id": "cam1", "rtsp_url": "rtsp://..."}'

api:
  base_url: "http://localhost:8000"
  docs_url: "http://localhost:8000/docs"
  endpoints:
    - method: "POST"
      path: "/cameras/"
      description: "Add a new camera"
      example: 'curl -X POST "http://localhost:8000/cameras/" -d \'{"camera_id": "cam1"}\''

license:
  name: "MIT License"
  file: "LICENSE"
"""

if __name__ == "__main__":
    # ì„¤ì • íŒŒì¼ì´ ì—†ìœ¼ë©´ ì˜ˆì œ ìƒì„±
    config_file = Path("docs/readme_config.yaml")
    if not config_file.exists():
        config_file.parent.mkdir(parents=True, exist_ok=True)
        with open(config_file, 'w', encoding='utf-8') as f:
            f.write(readme_config_example)
        print(f"Created example config file: {config_file}")
    
    # README ìƒì„±
    generator = ReadmeGenerator()
    readme_content = generator.generate_readme()
    
    with open("README.md", 'w', encoding='utf-8') as f:
        f.write(readme_content)
    
    print("âœ… README.md generated successfully!")
```

ì´ ë¬¸ì„œí™” ì‹œìŠ¤í…œ ê·œì¹™ë“¤ì„ í†µí•´ API ë¬¸ì„œ, ì‚¬ìš©ì ê°€ì´ë“œ, ê°œë°œì ë¬¸ì„œë¥¼ ìë™ìœ¼ë¡œ ìƒì„±í•˜ê³  ìœ ì§€í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

