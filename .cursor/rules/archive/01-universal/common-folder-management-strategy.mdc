---
description: 
globs: 
alwaysApply: false
---
# Common í´ë” ê´€ë¦¬ ì „ëµ (Common Folder Management Strategy)

## ğŸ¯ ëª©ì 

**Common í´ë”**ëŠ” ëª¨ë“  ë„ë©”ì¸ì—ì„œ ê³µí†µìœ¼ë¡œ ì‚¬ìš©ë˜ëŠ” ë²”ìš© ìœ í‹¸ë¦¬í‹°ì™€ ê¸°ëŠ¥ì„ ì œê³µí•˜ëŠ” í•µì‹¬ ê¸°ë°˜ ê³„ì¸µì…ë‹ˆë‹¤.  
ë„ë©”ì¸ ë…ë¦½ì ì´ë©° ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ì„ í¬í•¨í•˜ì§€ ì•ŠëŠ” ìˆœìˆ˜í•œ ê¸°ìˆ ì  ìœ í‹¸ë¦¬í‹°ë§Œì„ í¬í•¨í•©ë‹ˆë‹¤.

## ğŸ“ Common í´ë” í‘œì¤€ êµ¬ì¡°

### í•„ìˆ˜ êµ¬ì¡° (ëª¨ë“  í”„ë¡œì íŠ¸ ê³µí†µ)
```
common/
â”œâ”€â”€ __init__.py                 # í•„ìˆ˜
â”œâ”€â”€ README.md                   # í•„ìˆ˜ - ì „ì²´ ê°œìš”
â”œâ”€â”€ CHANGELOG.md                # í•„ìˆ˜ - ë³€ê²½ ì´ë ¥
â”œâ”€â”€ constants.py                # í•„ìˆ˜ - ì „ì—­ ìƒìˆ˜
â”œâ”€â”€ enums.py                    # í•„ìˆ˜ - ê³µí†µ ì—´ê±°í˜•
â”œâ”€â”€ config/                     # ì„¤ì • ê´€ë¦¬
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ README.md
â”‚   â”œâ”€â”€ config_manager.py       # ì„¤ì • ë¡œë”©/ê´€ë¦¬
â”‚   â”œâ”€â”€ loader.py               # ì„¤ì • íŒŒì¼ ë¡œë”
â”‚   â””â”€â”€ validator.py            # ì„¤ì • ìœ íš¨ì„± ê²€ì‚¬
â”œâ”€â”€ file/                       # íŒŒì¼ ì…ì¶œë ¥
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ README.md
â”‚   â”œâ”€â”€ image_io.py             # ì´ë¯¸ì§€ íŒŒì¼ ì²˜ë¦¬
â”‚   â”œâ”€â”€ video_io.py             # ë¹„ë””ì˜¤ íŒŒì¼ ì²˜ë¦¬
â”‚   â”œâ”€â”€ json_utils.py           # JSON ìœ í‹¸ë¦¬í‹°
â”‚   â””â”€â”€ yaml_utils.py           # YAML ìœ í‹¸ë¦¬í‹°
â”œâ”€â”€ logging/                    # ë¡œê¹… ì‹œìŠ¤í…œ
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ README.md
â”‚   â”œâ”€â”€ logger.py               # ë¡œê±° ì„¤ì •
â”‚   â”œâ”€â”€ filters.py              # ë¡œê·¸ í•„í„°
â”‚   â”œâ”€â”€ formatters.py           # ë¡œê·¸ í¬ë§·í„°
â”‚   â””â”€â”€ handlers.py             # ë¡œê·¸ í•¸ë“¤ëŸ¬
â””â”€â”€ utils/                      # ë²”ìš© ìœ í‹¸ë¦¬í‹°
    â”œâ”€â”€ __init__.py
    â”œâ”€â”€ README.md
    â”œâ”€â”€ hardware_detector.py    # í•˜ë“œì›¨ì–´ ê°ì§€
    â”œâ”€â”€ path_utils.py           # ê²½ë¡œ ìœ í‹¸ë¦¬í‹°
    â””â”€â”€ time_utils.py           # ì‹œê°„ ìœ í‹¸ë¦¬í‹°
```

### ë¹„ì „ ì‹œìŠ¤í…œ íŠ¹í™” ì¶”ê°€ êµ¬ì¡° (ì„ íƒì )
```
common/
â”œâ”€â”€ camera/                     # ì¹´ë©”ë¼ ê´€ë ¨ ìœ í‹¸ë¦¬í‹°
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ README.md
â”‚   â”œâ”€â”€ camera_detector.py      # ì¹´ë©”ë¼ ê°ì§€
â”‚   â”œâ”€â”€ stream_utils.py         # ìŠ¤íŠ¸ë¦¼ ìœ í‹¸ë¦¬í‹°
â”‚   â””â”€â”€ codec_utils.py          # ì½”ë± ìœ í‹¸ë¦¬í‹°
â”œâ”€â”€ image/                      # ì´ë¯¸ì§€ ê¸°ë³¸ ì²˜ë¦¬
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ README.md
â”‚   â”œâ”€â”€ basic_ops.py            # ê¸°ë³¸ ì´ë¯¸ì§€ ì—°ì‚°
â”‚   â”œâ”€â”€ format_converter.py     # í¬ë§· ë³€í™˜
â”‚   â””â”€â”€ quality_checker.py      # í’ˆì§ˆ ê²€ì‚¬
â””â”€â”€ validation/                 # ë°ì´í„° ê²€ì¦
    â”œâ”€â”€ __init__.py
    â”œâ”€â”€ README.md
    â”œâ”€â”€ type_checker.py          # íƒ€ì… ê²€ì¦
    â”œâ”€â”€ range_validator.py       # ë²”ìœ„ ê²€ì¦
    â””â”€â”€ format_validator.py      # í¬ë§· ê²€ì¦
```

## ğŸ”„ ì½”ë“œ ìŠ¹ê²© ì‹œìŠ¤í…œ (Domains â†’ Shared â†’ Common)

### ìŠ¹ê²© ê²½ë¡œ ë° ê¸°ì¤€
```python
CODE_PROMOTION_PATH = {
    'domains': {
        'target': 'shared',
        'criteria': '2ê°œ ì´ìƒ ë„ë©”ì¸ì—ì„œ ì‚¬ìš©',
        'review_process': 'domain_team_review'
    },
    'shared': {
        'target': 'common',
        'criteria': 'ì™„ì „í•œ ë„ë©”ì¸ ë…ë¦½ì„± + ë²”ìš©ì„±',
        'review_process': 'architecture_team_review'
    }
}

# ìŠ¹ê²© ê¸°ì¤€ ìƒì„¸
PROMOTION_CRITERIA = {
    'domains_to_shared': {
        'reusability': {
            'min_domain_usage': 2,           # ìµœì†Œ 2ê°œ ë„ë©”ì¸ì—ì„œ ì‚¬ìš©
            'usage_frequency': 'high',       # ë†’ì€ ì‚¬ìš© ë¹ˆë„
            'weight': 0.4
        },
        'abstraction_level': {
            'domain_independence': 0.8,      # 80% ì´ìƒ ë„ë©”ì¸ ë…ë¦½ì 
            'business_logic_free': True,     # ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ ì—†ìŒ
            'weight': 0.3
        },
        'stability': {
            'test_coverage': 0.9,            # 90% ì´ìƒ í…ŒìŠ¤íŠ¸ ì»¤ë²„ë¦¬ì§€
            'api_stability': True,           # ì•ˆì •ì ì¸ API
            'weight': 0.3
        }
    },
    'shared_to_common': {
        'universality': {
            'domain_agnostic': True,         # ì™„ì „í•œ ë„ë©”ì¸ ë¬´ê´€ì„±
            'business_logic_free': True,     # ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ ì™„ì „ ì œê±°
            'technical_utility_only': True, # ìˆœìˆ˜ ê¸°ìˆ ì  ìœ í‹¸ë¦¬í‹°ë§Œ
            'weight': 0.5
        },
        'stability': {
            'api_frozen': True,              # API ê³ ì • (í•˜ìœ„ í˜¸í™˜ì„±)
            'test_coverage': 0.95,           # 95% ì´ìƒ í…ŒìŠ¤íŠ¸ ì»¤ë²„ë¦¬ì§€
            'production_proven': True,       # í”„ë¡œë•ì…˜ ê²€ì¦ ì™„ë£Œ
            'weight': 0.3
        },
        'documentation': {
            'complete_docs': True,           # ì™„ì „í•œ ë¬¸ì„œí™”
            'usage_examples': True,          # ì‚¬ìš© ì˜ˆì œ í¬í•¨
            'api_reference': True,           # API ë ˆí¼ëŸ°ìŠ¤ ì™„ì„±
            'weight': 0.2
        }
    }
}
```

### ìŠ¹ê²© í›„ë³´ ìë™ ë¶„ì„
```python
class CodePromotionAnalyzer:
    """ì½”ë“œ ìŠ¹ê²© í›„ë³´ ë¶„ì„ ì‹œìŠ¤í…œ"""
    
    def __init__(self, project_root: str):
        self.project_root = Path(project_root)
        self.criteria = PROMOTION_CRITERIA
        
    def analyze_domains_to_shared(self) -> List[Dict]:
        """Domains â†’ Shared ìŠ¹ê²© í›„ë³´ ë¶„ì„"""
        candidates = []
        
        domains_path = Path('domains')
        for domain_dir in domains_path.iterdir():
            if not domain_dir.is_dir():
                continue
                
            # ë„ë©”ì¸ ë‚´ ê³µí†µ ê¸°ëŠ¥ ë¶„ì„
            common_functions = self._extract_common_functions(domain_dir)
            
            for func_info in common_functions:
                score = self._calculate_promotion_score(
                    func_info, 'domains_to_shared'
                )
                
                if score >= 0.7:  # 70% ì´ìƒ ì ìˆ˜
                    candidates.append({
                        'source_path': func_info['path'],
                        'target_path': f'shared/{func_info["category"]}/{func_info["name"]}',
                        'score': score,
                        'justification': self._generate_justification(func_info, score)
                    })
        
        return sorted(candidates, key=lambda x: x['score'], reverse=True)
    
    def analyze_shared_to_common(self) -> List[Dict]:
        """Shared â†’ Common ìŠ¹ê²© í›„ë³´ ë¶„ì„"""
        candidates = []
        
        shared_path = Path('shared')
        for module_dir in shared_path.iterdir():
            if not module_dir.is_dir():
                continue
                
            # ëª¨ë“ˆ ë‚´ ë²”ìš© ê¸°ëŠ¥ ë¶„ì„
            universal_functions = self._extract_universal_functions(module_dir)
            
            for func_info in universal_functions:
                score = self._calculate_promotion_score(
                    func_info, 'shared_to_common'
                )
                
                if score >= 0.8:  # 80% ì´ìƒ ì ìˆ˜ (ë” ì—„ê²©)
                    candidates.append({
                        'source_path': func_info['path'],
                        'target_path': f'common/{func_info["category"]}/{func_info["name"]}',
                        'score': score,
                        'justification': self._generate_justification(func_info, score)
                    })
        
        return sorted(candidates, key=lambda x: x['score'], reverse=True)
    
    def _extract_common_functions(self, domain_path: Path) -> List[Dict]:
        """ë„ë©”ì¸ì—ì„œ ê³µí†µ ê¸°ëŠ¥ ì¶”ì¶œ"""
        common_functions = []
        
        # ë„ë©”ì¸ ë‚´ íŒŒì¼ë“¤ì„ ìŠ¤ìº”í•˜ì—¬ ì¬ì‚¬ìš© ê°€ëŠ¥í•œ í•¨ìˆ˜ ì‹ë³„
        for py_file in domain_path.rglob('*.py'):
            if py_file.name.startswith('__'):
                continue
                
            functions = self._analyze_file_functions(py_file)
            
            for func in functions:
                # ë‹¤ë¥¸ ë„ë©”ì¸ì—ì„œë„ ì‚¬ìš©ë  ê°€ëŠ¥ì„± ë¶„ì„
                reusability_score = self._calculate_reusability(func)
                
                if reusability_score > 0.6:
                    common_functions.append({
                        'path': str(py_file),
                        'name': func['name'],
                        'category': self._categorize_function(func),
                        'reusability_score': reusability_score,
                        'domain_specificity': self._calculate_domain_specificity(func)
                    })
        
        return common_functions
    
    def _extract_universal_functions(self, module_path: Path) -> List[Dict]:
        """Shared ëª¨ë“ˆì—ì„œ ë²”ìš© ê¸°ëŠ¥ ì¶”ì¶œ"""
        universal_functions = []
        
        for py_file in module_path.rglob('*.py'):
            if py_file.name.startswith('__'):
                continue
                
            functions = self._analyze_file_functions(py_file)
            
            for func in functions:
                # ì™„ì „í•œ ë„ë©”ì¸ ë…ë¦½ì„± ë¶„ì„
                domain_independence = self._calculate_domain_independence(func)
                
                if domain_independence > 0.9:  # 90% ì´ìƒ ë„ë©”ì¸ ë…ë¦½ì 
                    universal_functions.append({
                        'path': str(py_file),
                        'name': func['name'],
                        'category': self._categorize_universal_function(func),
                        'domain_independence': domain_independence,
                        'technical_utility_score': self._calculate_technical_utility(func)
                    })
        
        return universal_functions
    
    def _calculate_promotion_score(self, func_info: Dict, promotion_type: str) -> float:
        """ìŠ¹ê²© ì ìˆ˜ ê³„ì‚°"""
        criteria = self.criteria[promotion_type]
        total_score = 0.0
        
        for criterion_name, criterion_config in criteria.items():
            criterion_score = self._evaluate_criterion(func_info, criterion_config)
            weighted_score = criterion_score * criterion_config['weight']
            total_score += weighted_score
        
        return total_score
    
    def _categorize_function(self, func: Dict) -> str:
        """í•¨ìˆ˜ë¥¼ ì¹´í…Œê³ ë¦¬ë³„ë¡œ ë¶„ë¥˜"""
        name = func['name'].lower()
        
        if any(keyword in name for keyword in ['config', 'setting', 'option']):
            return 'config'
        elif any(keyword in name for keyword in ['log', 'debug', 'trace']):
            return 'logging'
        elif any(keyword in name for keyword in ['file', 'io', 'read', 'write']):
            return 'file'
        elif any(keyword in name for keyword in ['util', 'helper', 'tool']):
            return 'utils'
        elif any(keyword in name for keyword in ['valid', 'check', 'verify']):
            return 'validation'
        else:
            return 'utils'  # ê¸°ë³¸ê°’
    
    def _categorize_universal_function(self, func: Dict) -> str:
        """ë²”ìš© í•¨ìˆ˜ë¥¼ Common ì¹´í…Œê³ ë¦¬ë³„ë¡œ ë¶„ë¥˜"""
        # ë” ì—„ê²©í•œ ë¶„ë¥˜ ê¸°ì¤€ ì ìš©
        return self._categorize_function(func)
```

## ğŸš« Common í´ë” ê¸ˆì§€ ì‚¬í•­

### ì ˆëŒ€ í¬í•¨í•˜ë©´ ì•ˆ ë˜ëŠ” ê²ƒë“¤
```python
COMMON_FOLDER_FORBIDDEN = {
    'business_logic': [
        'ë„ë©”ì¸ë³„ ë¹„ì¦ˆë‹ˆìŠ¤ ê·œì¹™',
        'ì—…ë¬´ í”„ë¡œì„¸ìŠ¤ ë¡œì§',
        'ë„ë©”ì¸ íŠ¹í™” ì•Œê³ ë¦¬ì¦˜'
    ],
    'domain_specific': [
        'ì–¼êµ´ì¸ì‹ ì „ìš© ê¸°ëŠ¥',
        'ë¶ˆëŸ‰ê²€ì¶œ ì „ìš© ê¸°ëŠ¥',
        'íŠ¹ì • ë„ë©”ì¸ ì—”í‹°í‹°'
    ],
    'ai_models': [
        'í›ˆë ¨ëœ ëª¨ë¸ ê°€ì¤‘ì¹˜',
        'ëª¨ë¸ ì•„í‚¤í…ì²˜ ì •ì˜',
        'ë„ë©”ì¸ë³„ ì¶”ë¡  ë¡œì§'
    ],
    'external_dependencies': [
        'íŠ¹ì • í•˜ë“œì›¨ì–´ ì˜ì¡´ ì½”ë“œ',
        'íŠ¹ì • ì„œë¹„ìŠ¤ API í´ë¼ì´ì–¸íŠ¸',
        'ë„ë©”ì¸ë³„ ì™¸ë¶€ ì—°ë™'
    ]
}

# ì˜¬ë°”ë¥¸ ìœ„ì¹˜
CORRECT_LOCATIONS = {
    'business_logic': 'domains/{domain_name}/core/',
    'domain_specific': 'domains/{domain_name}/ ë˜ëŠ” shared/{category}/',
    'ai_models': 'models/ ë˜ëŠ” domains/{domain_name}/infrastructure/models/',
    'external_dependencies': 'domains/{domain_name}/infrastructure/ ë˜ëŠ” shared/{category}/'
}
```

## ğŸ“‹ Common í´ë” í’ˆì§ˆ ê¸°ì¤€

### ì½”ë“œ í’ˆì§ˆ ìš”êµ¬ì‚¬í•­
```python
COMMON_QUALITY_STANDARDS = {
    'test_coverage': {
        'minimum': 95,  # 95% ì´ìƒ í•„ìˆ˜
        'target': 100,  # 100% ëª©í‘œ
        'types': ['unit', 'integration', 'property']
    },
    'documentation': {
        'docstring_coverage': 100,  # 100% í•„ìˆ˜
        'type_hints': 100,          # 100% í•„ìˆ˜
        'examples': True,           # ì‚¬ìš© ì˜ˆì œ í•„ìˆ˜
        'api_reference': True       # API ë ˆí¼ëŸ°ìŠ¤ í•„ìˆ˜
    },
    'code_style': {
        'black_formatted': True,    # Black í¬ë§·íŒ… í•„ìˆ˜
        'isort_sorted': True,       # isort ì •ë ¬ í•„ìˆ˜
        'flake8_compliant': True,   # Flake8 ì¤€ìˆ˜ í•„ìˆ˜
        'mypy_typed': True          # MyPy íƒ€ì… ì²´í¬ í•„ìˆ˜
    },
    'api_stability': {
        'backward_compatible': True, # í•˜ìœ„ í˜¸í™˜ì„± í•„ìˆ˜
        'semantic_versioning': True, # ì‹œë§¨í‹± ë²„ì €ë‹ í•„ìˆ˜
        'deprecation_policy': True   # íê¸° ì •ì±… í•„ìˆ˜
    }
}
```

### ìë™ í’ˆì§ˆ ê²€ì‚¬
```python
class CommonQualityChecker:
    """Common í´ë” í’ˆì§ˆ ìë™ ê²€ì‚¬"""
    
    def __init__(self):
        self.standards = COMMON_QUALITY_STANDARDS
        
    def check_all(self) -> Dict[str, bool]:
        """ì „ì²´ í’ˆì§ˆ ê²€ì‚¬"""
        results = {}
        
        results['test_coverage'] = self._check_test_coverage()
        results['documentation'] = self._check_documentation()
        results['code_style'] = self._check_code_style()
        results['api_stability'] = self._check_api_stability()
        results['forbidden_content'] = self._check_forbidden_content()
        
        return results
    
    def _check_test_coverage(self) -> bool:
        """í…ŒìŠ¤íŠ¸ ì»¤ë²„ë¦¬ì§€ ê²€ì‚¬"""
        # pytest-covë¥¼ ì‚¬ìš©í•œ ì»¤ë²„ë¦¬ì§€ ì¸¡ì •
        result = subprocess.run([
            'pytest', '--cov=common', '--cov-report=json'
        ], capture_output=True, text=True)
        
        if result.returncode == 0:
            with open('coverage.json', 'r') as f:
                coverage_data = json.load(f)
                total_coverage = coverage_data['totals']['percent_covered']
                return total_coverage >= self.standards['test_coverage']['minimum']
        
        return False
    
    def _check_documentation(self) -> bool:
        """ë¬¸ì„œí™” í’ˆì§ˆ ê²€ì‚¬"""
        # ëª¨ë“  public í•¨ìˆ˜/í´ë˜ìŠ¤ì— docstring ì¡´ì¬ ì—¬ë¶€ í™•ì¸
        common_path = Path('common')
        
        for py_file in common_path.rglob('*.py'):
            if not self._check_file_documentation(py_file):
                return False
        
        return True
    
    def _check_forbidden_content(self) -> bool:
        """ê¸ˆì§€ëœ ë‚´ìš© í¬í•¨ ì—¬ë¶€ ê²€ì‚¬"""
        forbidden_keywords = [
            'face_recognition', 'factory_defect', 'powerline_inspection',
            'torch.nn', 'tensorflow', 'model.predict',
            'business_rule', 'domain_logic'
        ]
        
        common_path = Path('common')
        
        for py_file in common_path.rglob('*.py'):
            with open(py_file, 'r', encoding='utf-8') as f:
                content = f.read().lower()
                
                for keyword in forbidden_keywords:
                    if keyword in content:
                        logger.warning(f"Forbidden keyword '{keyword}' found in {py_file}")
                        return False
        
        return True
```

## ğŸ“š Common ëª¨ë“ˆ ì‚¬ìš© ê°€ì´ë“œë¼ì¸

### ì˜¬ë°”ë¥¸ ì‚¬ìš© íŒ¨í„´
```python
# âœ… ì˜¬ë°”ë¥¸ ì‚¬ìš© - ë„ë©”ì¸ ë…ë¦½ì  ìœ í‹¸ë¦¬í‹°
from common.file.image_io import load_image, save_image
from common.utils.path_utils import ensure_dir_exists
from common.logging import get_logger

def process_any_image(image_path: str, output_path: str):
    """ë„ë©”ì¸ì— ê´€ê³„ì—†ì´ ì‚¬ìš© ê°€ëŠ¥í•œ ì´ë¯¸ì§€ ì²˜ë¦¬"""
    logger = get_logger(__name__)
    
    # ì´ë¯¸ì§€ ë¡œë”© (í¬ë§· ë¬´ê´€)
    image = load_image(image_path)
    
    # ì¶œë ¥ ë””ë ‰í† ë¦¬ í™•ì¸
    ensure_dir_exists(output_path)
    
    # ì²˜ë¦¬ëœ ì´ë¯¸ì§€ ì €ì¥
    save_image(image, output_path)
    logger.info(f"Image processed: {image_path} -> {output_path}")
```

### ì˜ëª»ëœ ì‚¬ìš© íŒ¨í„´
```python
# âŒ ì˜ëª»ëœ ì‚¬ìš© - ë„ë©”ì¸ íŠ¹í™” ë¡œì§
from common.face.face_detector import detect_faces  # ê¸ˆì§€!
from common.business.quality_rules import check_defect  # ê¸ˆì§€!

# âŒ ì´ëŸ° ê²ƒë“¤ì€ commonì— ìˆìœ¼ë©´ ì•ˆ ë¨
def detect_faces_in_image(image):  # â†’ shared/vision_core/detection/
    pass

def apply_business_rule(data):     # â†’ domains/{domain}/core/
    pass

def load_face_model():             # â†’ domains/face_recognition/infrastructure/
    pass
```

## ğŸ”„ ë§ˆì´ê·¸ë ˆì´ì…˜ ì „ëµ

### ê¸°ì¡´ ì½”ë“œë¥¼ Commonìœ¼ë¡œ ì´ë™í•˜ëŠ” ì ˆì°¨
```python
MIGRATION_PROCESS = {
    'step_1_analysis': {
        'description': 'ìŠ¹ê²© í›„ë³´ ìë™ ë¶„ì„',
        'tools': ['CodePromotionAnalyzer'],
        'output': 'ìŠ¹ê²© í›„ë³´ ë¦¬ìŠ¤íŠ¸'
    },
    'step_2_review': {
        'description': 'ì•„í‚¤í…ì²˜ íŒ€ ê²€í† ',
        'criteria': PROMOTION_CRITERIA,
        'approval_required': True
    },
    'step_3_refactoring': {
        'description': 'ë„ë©”ì¸ ë…ë¦½ì ìœ¼ë¡œ ë¦¬íŒ©í† ë§',
        'tasks': [
            'ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ ì œê±°',
            'ë„ë©”ì¸ íŠ¹í™” ì˜ì¡´ì„± ì œê±°',
            'ë²”ìš© ì¸í„°í˜ì´ìŠ¤ ì„¤ê³„',
            'ì™„ì „í•œ í…ŒìŠ¤íŠ¸ ì‘ì„±'
        ]
    },
    'step_4_migration': {
        'description': 'ì‹¤ì œ íŒŒì¼ ì´ë™ ë° import ìˆ˜ì •',
        'automation': True,
        'validation': 'ìë™ í…ŒìŠ¤íŠ¸ ì‹¤í–‰'
    },
    'step_5_cleanup': {
        'description': 'ê¸°ì¡´ ìœ„ì¹˜ ì •ë¦¬ ë° ë¬¸ì„œ ì—…ë°ì´íŠ¸',
        'tasks': [
            'ê¸°ì¡´ íŒŒì¼ ì‚­ì œ',
            'import ê²½ë¡œ ì—…ë°ì´íŠ¸',
            'ë¬¸ì„œ ì—…ë°ì´íŠ¸',
            'CHANGELOG ì—…ë°ì´íŠ¸'
        ]
    }
}
```

ì´ ì „ëµì„ í†µí•´ **Common í´ë”ê°€ ì§„ì •í•œ ê³µí†µ ê¸°ë°˜ ê³„ì¸µ**ìœ¼ë¡œì„œ ì—­í• ì„ ìˆ˜í–‰í•˜ë©°, **ë„ë©”ì¸ ë…ë¦½ì ì´ê³  ì¬ì‚¬ìš© ê°€ëŠ¥í•œ ê³ í’ˆì§ˆ ìœ í‹¸ë¦¬í‹°**ë§Œì„ í¬í•¨í•˜ë„ë¡ ê´€ë¦¬ë©ë‹ˆë‹¤.


