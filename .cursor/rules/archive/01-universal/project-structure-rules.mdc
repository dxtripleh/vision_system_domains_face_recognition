---
description: 
globs: 
alwaysApply: true
---
# í”„ë¡œì íŠ¸ êµ¬ì¡° ê·œì¹™ (Project Structure Rules)

ì´ ê·œì¹™ì€ ëŒ€ê·œëª¨ í”„ë¡œì íŠ¸ì˜ í´ë” êµ¬ì¡°, ê³„ì¸µ ê´€ë¦¬, ì˜ì¡´ì„± ê·œì¹™ì— ê´€í•œ ë²”ìš© í‘œì¤€ì…ë‹ˆë‹¤.

## ğŸ“ í‘œì¤€ í”„ë¡œì íŠ¸ êµ¬ì¡°

### ìµœìƒìœ„ í´ë” êµ¬ì¡° (í˜„ì¬ ë¹„ì „ ì‹œìŠ¤í…œ êµ¬ì¡°)
```
vision_system/
â”œâ”€â”€ domains/                   # ë„ë©”ì¸ë³„ ë…ë¦½ ê°œë°œ
â”‚   â”œâ”€â”€ face_recognition/      # ì–¼êµ´ì¸ì‹ ë„ë©”ì¸
â”‚   â”‚   â”œâ”€â”€ core/              # ë„ë©”ì¸ í•µì‹¬ ë¡œì§ (DDD)
â”‚   â”‚   â”œâ”€â”€ infrastructure/    # ì¸í”„ë¼ ê³„ì¸µ
â”‚   â”‚   â””â”€â”€ interfaces/        # API ì¸í„°í˜ì´ìŠ¤
â”‚   â”œâ”€â”€ factory_defect/        # ê³µì¥ ë¶ˆëŸ‰ ê²€ì¶œ ë„ë©”ì¸ (í–¥í›„)
â”‚   â””â”€â”€ powerline_inspection/  # ì „ì„  ê²€ì‚¬ ë„ë©”ì¸ (í–¥í›„)
â”œâ”€â”€ shared/                    # ê³µí†µ ëª¨ë“ˆ (ì ì§„ì  í™•ì¥)
â”‚   â”œâ”€â”€ vision_core/           # ë¹„ì „ ì•Œê³ ë¦¬ì¦˜ ê³µí†µ ëª¨ë“ˆ
â”‚   â””â”€â”€ security/              # ë³´ì•ˆ ëª¨ë“ˆ (GDPR ì¤€ìˆ˜)
â”œâ”€â”€ common/                    # ë²”ìš© ìœ í‹¸ë¦¬í‹° ë° ê¸°ëŠ¥
â”œâ”€â”€ config/                    # ì „ì—­ ì„¤ì • ê´€ë¦¬
â”œâ”€â”€ models/                    # ëª¨ë¸ ì €ì¥ì†Œ
â”‚   â”œâ”€â”€ weights/               # ëª¨ë¸ ê°€ì¤‘ì¹˜
â”‚   â”œâ”€â”€ metadata/              # ëª¨ë¸ ë©”íƒ€ë°ì´í„°
â”‚   â””â”€â”€ configs/               # ëª¨ë¸ ì„¤ì •
â”œâ”€â”€ datasets/                  # ğŸ¯ í•™ìŠµ ì „ìš© ë°ì´í„° (ML ë°ì´í„°ì…‹)
â”œâ”€â”€ data/                      # ğŸ¯ ëŸ°íƒ€ì„ ì „ìš© ë°ì´í„°
â”‚   â”œâ”€â”€ temp/                  # ì„ì‹œ íŒŒì¼
â”‚   â”œâ”€â”€ logs/                  # ë¡œê·¸ íŒŒì¼
â”‚   â””â”€â”€ output/                # ê²°ê³¼ë¬¼ ì €ì¥
â”œâ”€â”€ scripts/                   # ìœ í‹¸ë¦¬í‹° ìŠ¤í¬ë¦½íŠ¸
â”œâ”€â”€ tests/                     # í…ŒìŠ¤íŠ¸ ì½”ë“œ
â”œâ”€â”€ requirements.txt           # ì˜ì¡´ì„± ì •ì˜
â”œâ”€â”€ README.md                 # í”„ë¡œì íŠ¸ ê°œìš”
â””â”€â”€ main.py                   # ë©”ì¸ ì§„ì…ì  (ì„ íƒì )
```

## ğŸ”— ê³„ì¸µë³„ ì˜ì¡´ì„± ê·œì¹™

### ê³„ì¸µ ì •ì˜ (Level 1ì´ ê°€ì¥ ë‚®ì€ ê³„ì¸µ)
```python
PROJECT_LAYERS = {
    'Level 1': ['common', 'config'],        # ê³µí†µ ìœ í‹¸ë¦¬í‹° ë° ì„¤ì • (ê¸°ë°˜ ê³„ì¸µ)
    'Level 2': ['shared'],                  # ê³µìœ  ëª¨ë“ˆ (ë¹„ì „ í•µì‹¬, ë³´ì•ˆ ë“±)
    'Level 3': ['models'],                  # ëª¨ë¸ ë° AI ê´€ë ¨
    'Level 4': ['domains'],                 # ë„ë©”ì¸ë³„ ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§
    'Level 5': ['applications']             # ìµœì¢… ì‚¬ìš©ì ì• í”Œë¦¬ì¼€ì´ì…˜ (í–¥í›„)
}

# ì˜ì¡´ì„± ê·œì¹™
DEPENDENCY_RULES = {
    'allowed': 'higher_level â†’ lower_level',  # ìƒìœ„ â†’ í•˜ìœ„ë§Œ í—ˆìš©
    'forbidden': 'lower_level â†’ higher_level', # í•˜ìœ„ â†’ ìƒìœ„ ê¸ˆì§€
    'circular': 'strictly_forbidden',          # ìˆœí™˜ ì˜ì¡´ì„± ì ˆëŒ€ ê¸ˆì§€
    'common_access': 'all_levels â†’ [common, config]',  # ëª¨ë“  ë ˆë²¨ì´ ê³µí†µ ë ˆì´ì–´ ì ‘ê·¼ ê°€ëŠ¥
    'domain_isolation': 'domains ê°„ ì§ì ‘ ì˜ì¡´ì„± ê¸ˆì§€'  # ë„ë©”ì¸ ê°„ ë…ë¦½ì„± ë³´ì¥
}
```

### ë„ë©”ì¸ ë…ë¦½ì„± ê·œì¹™
```python
DOMAIN_INDEPENDENCE_RULES = {
    'direct_imports_forbidden': [
        'domains.face_recognition â†’ domains.factory_defect',
        'domains.factory_defect â†’ domains.powerline_inspection',
        'domains.* â†’ domains.*'  # ëª¨ë“  ë„ë©”ì¸ ê°„ ì§ì ‘ import ê¸ˆì§€
    ],
    'allowed_dependencies': [
        'domains.* â†’ shared.*',     # ë„ë©”ì¸ â†’ ê³µìœ  ëª¨ë“ˆ í—ˆìš©
        'domains.* â†’ common.*',     # ë„ë©”ì¸ â†’ ê³µí†µ ìœ í‹¸ë¦¬í‹° í—ˆìš©
        'domains.* â†’ config.*',     # ë„ë©”ì¸ â†’ ì„¤ì • í—ˆìš©
        'domains.* â†’ models.*'      # ë„ë©”ì¸ â†’ ëª¨ë¸ í—ˆìš©
    ],
    'communication_via_shared': True  # ë„ë©”ì¸ ê°„ í†µì‹ ì€ shared ëª¨ë“ˆì„ í†µí•´ì„œë§Œ
}
```

### ì˜ì¡´ì„± ê²€ì¦ ì‹œìŠ¤í…œ
```python
class DependencyValidator:
    """í”„ë¡œì íŠ¸ ì˜ì¡´ì„± ê·œì¹™ ê²€ì¦"""
    
    def __init__(self, project_root: str):
        self.project_root = Path(project_root)
        self.layers = PROJECT_LAYERS
        
    def validate_import(self, from_module: str, to_module: str) -> bool:
        """import ë¬¸ì˜ ì˜ì¡´ì„± ê·œì¹™ ê²€ì¦"""
        from_layer = self._get_layer(from_module)
        to_layer = self._get_layer(to_module)
        
        # ê³µí†µ ë ˆì´ì–´ëŠ” ëª¨ë“  ê³³ì—ì„œ ì ‘ê·¼ ê°€ëŠ¥
        if to_layer in ['common', 'config']:
            return True
        
        # ë„ë©”ì¸ ê°„ ì§ì ‘ import ê¸ˆì§€
        if from_layer == 'domains' and to_layer == 'domains':
            from_domain = self._get_domain(from_module)
            to_domain = self._get_domain(to_module)
            if from_domain != to_domain:
                return False  # ë‹¤ë¥¸ ë„ë©”ì¸ìœ¼ë¡œì˜ ì§ì ‘ import ê¸ˆì§€
            
        # ê°™ì€ ë ˆì´ì–´ ë‚´ ì ‘ê·¼ í—ˆìš© (ê°™ì€ ë„ë©”ì¸ ë‚´)
        if from_layer == to_layer:
            return True
            
        # ìƒìœ„ ë ˆì´ì–´ì—ì„œ í•˜ìœ„ ë ˆì´ì–´ë¡œë§Œ ì ‘ê·¼ í—ˆìš©
        from_level = self._get_level(from_layer)
        to_level = self._get_level(to_layer)
        
        return from_level > to_level
    
    def _get_layer(self, module_path: str) -> str:
        """ëª¨ë“ˆ ê²½ë¡œì—ì„œ ë ˆì´ì–´ ì¶”ì¶œ"""
        parts = module_path.split('.')
        if len(parts) > 0:
            return parts[0]
        return 'unknown'
    
    def _get_domain(self, module_path: str) -> str:
        """ë„ë©”ì¸ ê²½ë¡œì—ì„œ ë„ë©”ì¸ëª… ì¶”ì¶œ"""
        parts = module_path.split('.')
        if len(parts) > 1 and parts[0] == 'domains':
            return parts[1]
        return 'unknown'
    
    def _get_level(self, layer: str) -> int:
        """ë ˆì´ì–´ì˜ ë ˆë²¨ ë²ˆí˜¸ ë°˜í™˜"""
        for level, layers in self.layers.items():
            if layer in layers:
                return int(level.split()[1])
        return 0

    def scan_project_dependencies(self) -> Dict[str, List[str]]:
        """í”„ë¡œì íŠ¸ ì „ì²´ ì˜ì¡´ì„± ìŠ¤ìº”"""
        violations = {}
        
        for py_file in self.project_root.rglob("*.py"):
            if py_file.name.startswith('__'):
                continue
                
            violations_in_file = self._scan_file_imports(py_file)
            if violations_in_file:
                violations[str(py_file)] = violations_in_file
                
        return violations
    
    def _scan_file_imports(self, file_path: Path) -> List[str]:
        """íŒŒì¼ì˜ import ë¬¸ ê²€ì¦"""
        violations = []
        
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read()
                
            # AST íŒŒì‹±ìœ¼ë¡œ import ë¬¸ ì¶”ì¶œ
            tree = ast.parse(content)
            
            for node in ast.walk(tree):
                if isinstance(node, ast.Import):
                    for alias in node.names:
                        if not self.validate_import(str(file_path), alias.name):
                            violations.append(f"Invalid import: {alias.name}")
                            
                elif isinstance(node, ast.ImportFrom):
                    if node.module:
                        if not self.validate_import(str(file_path), node.module):
                            violations.append(f"Invalid import from: {node.module}")
                            
        except Exception as e:
            violations.append(f"Error parsing file: {str(e)}")
            
        return violations
```

## ğŸ“¦ Common í´ë” í‘œì¤€ êµ¬ì¡°

### Common í´ë” í•„ìˆ˜ êµ¬ì„± ìš”ì†Œ
```python
COMMON_FOLDER_STRUCTURE = {
    'required_files': [
        '__init__.py',
        'README.md', 
        'CHANGELOG.md',
        'constants.py',
        'enums.py'
    ],
    'required_folders': {
        'config/': {
            'purpose': 'ì„¤ì • ê´€ë¦¬',
            'files': ['__init__.py', 'config_manager.py', 'loader.py', 'validator.py']
        },
        'file/': {
            'purpose': 'íŒŒì¼ ì…ì¶œë ¥',
            'files': ['__init__.py', 'image_io.py', 'video_io.py', 'json_utils.py', 'yaml_utils.py']
        },
        'logging/': {
            'purpose': 'ë¡œê¹… ì‹œìŠ¤í…œ',
            'files': ['__init__.py', 'logger.py', 'filters.py', 'formatters.py', 'handlers.py']
        },
        'utils/': {
            'purpose': 'ë²”ìš© ìœ í‹¸ë¦¬í‹°',
            'files': ['__init__.py', 'hardware_detector.py', 'path_utils.py', 'time_utils.py']
        }
    }
}
```

## ğŸ—ï¸ Shared í´ë” í‘œì¤€ êµ¬ì¡°

### Shared í´ë” êµ¬ì„± (ë¹„ì „ ì‹œìŠ¤í…œ íŠ¹í™”)
```python
SHARED_FOLDER_STRUCTURE = {
    'vision_core/': {
        'purpose': 'ë¹„ì „ ì•Œê³ ë¦¬ì¦˜ ê³µí†µ ëª¨ë“ˆ',
        'submodules': [
            'detection/',      # ê°ì²´/ì–¼êµ´ ê²€ì¶œ ê³µí†µ ê¸°ëŠ¥
            'recognition/',    # ì¸ì‹ ê³µí†µ ê¸°ëŠ¥
            'preprocessing/',  # ì „ì²˜ë¦¬ ê³µí†µ ê¸°ëŠ¥
            'postprocessing/', # í›„ì²˜ë¦¬ ê³µí†µ ê¸°ëŠ¥
            'tracking/',       # ì¶”ì  ê³µí†µ ê¸°ëŠ¥
            'visualization/'   # ì‹œê°í™” ê³µí†µ ê¸°ëŠ¥
        ]
    },
    'security/': {
        'purpose': 'ë³´ì•ˆ ë° ê°œì¸ì •ë³´ ë³´í˜¸',
        'submodules': [
            'privacy/',        # ê°œì¸ì •ë³´ ë³´í˜¸ (GDPR)
            'encryption/',     # ì•”í˜¸í™”
            'authentication/', # ì¸ì¦
            'audit/'          # ê°ì‚¬ ë¡œê¹…
        ]
    }
}
```

### ì‹±ê¸€í†¤ í´ë˜ìŠ¤ í‘œì¤€ (Common í´ë” ì „ìš©)
```python
class SingletonMeta(type):
    """ìŠ¤ë ˆë“œ ì•ˆì „ ì‹±ê¸€í†¤ ë©”íƒ€í´ë˜ìŠ¤"""
    _instances = {}
    _lock = threading.Lock()
    
    def __call__(cls, *args, **kwargs):
        if cls not in cls._instances:
            with cls._lock:
                if cls not in cls._instances:
                    cls._instances[cls] = super().__call__(*args, **kwargs)
        return cls._instances[cls]

# ì‚¬ìš© ì˜ˆì‹œ
class ConfigManager(metaclass=SingletonMeta):
    """ì„¤ì • ê´€ë¦¬ ì‹±ê¸€í†¤"""
    
    def __init__(self):
        if hasattr(self, '_initialized'):
            return
        self._initialized = True
        self._config = {}
        self._load_config()
    
    def _load_config(self):
        """ì„¤ì • íŒŒì¼ ë¡œë”©"""
        pass

class HardwareDetector(metaclass=SingletonMeta):
    """í•˜ë“œì›¨ì–´ ê°ì§€ ì‹±ê¸€í†¤"""
    
    def __init__(self):
        if hasattr(self, '_initialized'):
            return
        self._initialized = True
        self._hardware_info = {}
        self._detect_hardware()
    
    def _detect_hardware(self):
        """í•˜ë“œì›¨ì–´ ê°ì§€"""
        pass
```

## ğŸ—‚ï¸ ì„¤ì • íŒŒì¼ ê´€ë¦¬ ì‹œìŠ¤í…œ

### JSON Schema ê¸°ë°˜ ê²€ì¦
```python
class ConfigValidator:
    """ì„¤ì • íŒŒì¼ ê²€ì¦ ì‹œìŠ¤í…œ"""
    
    def __init__(self, schema_dir: str = 'config/schemas'):
        self.schema_dir = Path(schema_dir)
        self.schemas = self._load_schemas()
    
    def _load_schemas(self) -> Dict[str, Dict]:
        """ìŠ¤í‚¤ë§ˆ íŒŒì¼ë“¤ ë¡œë”©"""
        schemas = {}
        
        for schema_file in self.schema_dir.glob('*.yaml'):
            with open(schema_file, 'r', encoding='utf-8') as f:
                schemas[schema_file.stem] = yaml.safe_load(f)
                
        return schemas
    
    def validate_config(self, config_file: str, schema_name: str) -> Dict:
        """ì„¤ì • íŒŒì¼ ê²€ì¦"""
        if schema_name not in self.schemas:
            return {'valid': False, 'error': f'Schema {schema_name} not found'}
        
        try:
            with open(config_file, 'r', encoding='utf-8') as f:
                config_data = yaml.safe_load(f)
            
            # JSON Schema ê²€ì¦
            jsonschema.validate(config_data, self.schemas[schema_name])
            
            return {'valid': True, 'data': config_data}
            
        except jsonschema.ValidationError as e:
            return {'valid': False, 'error': f'Validation error: {e.message}'}
        except Exception as e:
            return {'valid': False, 'error': f'File error: {str(e)}'}

# ê¸°ë³¸ ìŠ¤í‚¤ë§ˆ í…œí”Œë¦¿
BASE_CONFIG_SCHEMA = {
    "type": "object",
    "required": ["version", "meta"],
    "properties": {
        "version": {
            "type": "string",
            "pattern": "^\\d+\\.\\d+\\.\\d+$"
        },
        "meta": {
            "type": "object",
            "required": ["description", "lastModified"],
            "properties": {
                "description": {"type": "string"},
                "lastModified": {"type": "string", "format": "date-time"},
                "status": {"enum": ["active", "deprecated", "experimental"]}
            }
        }
    }
}
```

### í™˜ê²½ë³„ ì„¤ì • ê´€ë¦¬
```python
class EnvironmentManager:
    """í™˜ê²½ë³„ ì„¤ì • ê´€ë¦¬"""
    
    def __init__(self, config_dir: str = 'config'):
        self.config_dir = Path(config_dir)
        self.current_env = os.getenv('ENVIRONMENT', 'development')
    
    def load_config(self, config_name: str) -> Dict:
        """í™˜ê²½ë³„ ì„¤ì • ë¡œë”© ë° ë³‘í•©"""
        # ê¸°ë³¸ ì„¤ì • ë¡œë”©
        base_config = self._load_base_config(config_name)
        
        # í™˜ê²½ë³„ ì„¤ì • ë¡œë”©
        env_config = self._load_env_config(config_name, self.current_env)
        
        # ì„¤ì • ë³‘í•© (í™˜ê²½ë³„ì´ ê¸°ë³¸ì„ ì˜¤ë²„ë¼ì´ë“œ)
        merged_config = self._deep_merge(base_config, env_config)
        
        # í™˜ê²½ ë³€ìˆ˜ ì¹˜í™˜
        resolved_config = self._resolve_env_variables(merged_config)
        
        return resolved_config
    
    def _load_base_config(self, config_name: str) -> Dict:
        """ê¸°ë³¸ ì„¤ì • íŒŒì¼ ë¡œë”©"""
        config_file = self.config_dir / f'{config_name}.yaml'
        if config_file.exists():
            with open(config_file, 'r', encoding='utf-8') as f:
                return yaml.safe_load(f) or {}
        return {}
    
    def _load_env_config(self, config_name: str, environment: str) -> Dict:
        """í™˜ê²½ë³„ ì„¤ì • íŒŒì¼ ë¡œë”©"""
        env_config_file = self.config_dir / 'environments' / f'{environment}_{config_name}.yaml'
        if env_config_file.exists():
            with open(env_config_file, 'r', encoding='utf-8') as f:
                return yaml.safe_load(f) or {}
        return {}
    
    def _deep_merge(self, base: Dict, override: Dict) -> Dict:
        """ë”•ì…”ë„ˆë¦¬ ê¹Šì€ ë³‘í•©"""
        result = base.copy()
        
        for key, value in override.items():
            if key in result and isinstance(result[key], dict) and isinstance(value, dict):
                result[key] = self._deep_merge(result[key], value)
            else:
                result[key] = value
                
        return result
    
    def _resolve_env_variables(self, config: Dict) -> Dict:
        """í™˜ê²½ ë³€ìˆ˜ ì¹˜í™˜ (${VAR} í˜•ì‹)"""
        def resolve_value(value):
            if isinstance(value, str):
                # ${VAR} íŒ¨í„´ ì¹˜í™˜
                pattern = r'\$\{([^}]+)\}'
                
                def replace_var(match):
                    var_name = match.group(1)
                    return os.getenv(var_name, match.group(0))  # í™˜ê²½ë³€ìˆ˜ê°€ ì—†ìœ¼ë©´ ì›ë³¸ ìœ ì§€
                
                return re.sub(pattern, replace_var, value)
            elif isinstance(value, dict):
                return {k: resolve_value(v) for k, v in value.items()}
            elif isinstance(value, list):
                return [resolve_value(item) for item in value]
            else:
                return value
        
        return resolve_value(config)
```

## ğŸ§¹ ì„ì‹œ ë°ì´í„° ê´€ë¦¬

### ìë™ ì •ë¦¬ ì‹œìŠ¤í…œ
```python
class TempDataManager:
    """ì„ì‹œ ë°ì´í„° ìë™ ê´€ë¦¬"""
    
    def __init__(self, temp_dir: str = 'data/temp'):
        self.temp_dir = Path(temp_dir)
        self.temp_dir.mkdir(parents=True, exist_ok=True)
        
        # ì •ë¦¬ ê·œì¹™
        self.cleanup_rules = {
            'max_age_hours': 24,      # 24ì‹œê°„ ì´ìƒ ëœ íŒŒì¼ ì‚­ì œ
            'max_size_mb': 1000,      # 1GB ì´ìƒ ì‹œ ì˜¤ë˜ëœ íŒŒì¼ë¶€í„° ì‚­ì œ
            'keep_recent_count': 10   # ìµœì‹  10ê°œ íŒŒì¼ì€ í•­ìƒ ìœ ì§€
        }
    
    def create_temp_file(self, prefix: str = 'temp', suffix: str = '.tmp') -> Path:
        """ì„ì‹œ íŒŒì¼ ìƒì„±"""
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S_%f')
        filename = f'{prefix}_{timestamp}{suffix}'
        temp_file = self.temp_dir / filename
        
        # íŒŒì¼ ìƒì„±
        temp_file.touch()
        
        # ì •ë¦¬ ì‘ì—… ìŠ¤ì¼€ì¤„ë§ (ë°±ê·¸ë¼ìš´ë“œ)
        threading.Thread(target=self._schedule_cleanup, daemon=True).start()
        
        return temp_file
    
    def _schedule_cleanup(self):
        """ì •ë¦¬ ì‘ì—… ìŠ¤ì¼€ì¤„ë§"""
        time.sleep(1)  # 1ì´ˆ í›„ ì •ë¦¬ ì‹¤í–‰
        self.cleanup_temp_files()
    
    def cleanup_temp_files(self):
        """ì„ì‹œ íŒŒì¼ ì •ë¦¬"""
        if not self.temp_dir.exists():
            return
        
        temp_files = list(self.temp_dir.glob('*'))
        
        # íŒŒì¼ í¬ê¸° ê¸°ì¤€ ì •ë¦¬
        total_size = sum(f.stat().st_size for f in temp_files if f.is_file())
        max_size_bytes = self.cleanup_rules['max_size_mb'] * 1024 * 1024
        
        if total_size > max_size_bytes:
            # ì˜¤ë˜ëœ íŒŒì¼ë¶€í„° ì‚­ì œ
            temp_files.sort(key=lambda f: f.stat().st_mtime)
            
            for file in temp_files[:-self.cleanup_rules['keep_recent_count']]:
                if file.is_file():
                    try:
                        file.unlink()
                    except:
                        pass
        
        # ë‚˜ì´ ê¸°ì¤€ ì •ë¦¬
        max_age_seconds = self.cleanup_rules['max_age_hours'] * 3600
        current_time = time.time()
        
        for file in temp_files:
            if file.is_file():
                file_age = current_time - file.stat().st_mtime
                if file_age > max_age_seconds:
                    try:
                        file.unlink()
                    except:
                        pass

# ì „ì—­ ì„ì‹œ ë°ì´í„° ë§¤ë‹ˆì €
temp_manager = TempDataManager()

# ì»¨í…ìŠ¤íŠ¸ ë§¤ë‹ˆì €ë¡œ ì‚¬ìš©
@contextmanager
def temp_file(prefix: str = 'temp', suffix: str = '.tmp'):
    """ì„ì‹œ íŒŒì¼ ì»¨í…ìŠ¤íŠ¸ ë§¤ë‹ˆì €"""
    temp_path = temp_manager.create_temp_file(prefix, suffix)
    try:
        yield temp_path
    finally:
        if temp_path.exists():
            temp_path.unlink()
```

## ğŸ“Š í”„ë¡œì íŠ¸ êµ¬ì¡° ê²€ì¦

### êµ¬ì¡° ê·œì¹™ ê²€ì¦ ìŠ¤í¬ë¦½íŠ¸
```python
def validate_project_structure() -> Dict[str, List[str]]:
    """í”„ë¡œì íŠ¸ êµ¬ì¡° ê·œì¹™ ê²€ì¦"""
    violations = []
    warnings = []
    
    # í•„ìˆ˜ í´ë” ê²€ì¦
    required_folders = ['common', 'config', 'core', 'features', 'scripts', 'tests']
    for folder in required_folders:
        if not Path(folder).exists():
            violations.append(f'Required folder missing: {folder}')
    
    # Common í´ë” êµ¬ì¡° ê²€ì¦
    common_violations = validate_common_structure()
    violations.extend(common_violations)
    
    # ì˜ì¡´ì„± ê·œì¹™ ê²€ì¦
    dependency_violations = DependencyValidator('.').scan_project_dependencies()
    if dependency_violations:
        violations.extend([f'{file}: {", ".join(errs)}' for file, errs in dependency_violations.items()])
    
    # íŒŒì¼ ë„¤ì´ë° ê²€ì¦
    naming_violations = validate_file_naming()
    warnings.extend(naming_violations)
    
    return {
        'violations': violations,
        'warnings': warnings,
        'status': 'PASS' if not violations else 'FAIL'
    }

def validate_common_structure() -> List[str]:
    """Common í´ë” êµ¬ì¡° ê²€ì¦"""
    violations = []
    common_path = Path('common')
    
    if not common_path.exists():
        return ['Common folder does not exist']
    
    # í•„ìˆ˜ íŒŒì¼ ê²€ì¦
    required_files = ['__init__.py', 'README.md', 'constants.py', 'enums.py']
    for file in required_files:
        if not (common_path / file).exists():
            violations.append(f'Common folder missing required file: {file}')
    
    # í•„ìˆ˜ ì„œë¸Œí´ë” ê²€ì¦
    required_subfolders = ['config', 'file', 'logging', 'utils']
    for folder in required_subfolders:
        folder_path = common_path / folder
        if not folder_path.exists():
            violations.append(f'Common folder missing required subfolder: {folder}')
        elif not (folder_path / '__init__.py').exists():
            violations.append(f'Common subfolder missing __init__.py: {folder}')
    
    return violations

def validate_file_naming() -> List[str]:
    """íŒŒì¼ ë„¤ì´ë° ê·œì¹™ ê²€ì¦"""
    warnings = []
    
    # Python íŒŒì¼ ë„¤ì´ë° ê²€ì¦
    for py_file in Path('.').rglob('*.py'):
        filename = py_file.name
        
        # snake_case ê²€ì¦
        if not re.match(r'^[a-z0-9_]+\.py$', filename):
            if not filename.startswith('__'):  # __init__.py ë“± ì˜ˆì™¸
                warnings.append(f'File name not in snake_case: {py_file}')
        
        # íŠ¹ìˆ˜ ì ‘ë‘ì‚¬ ê²€ì¦
        if filename.startswith('run_') and not py_file.parent.name == 'scripts':
            warnings.append(f'run_ prefix file outside scripts folder: {py_file}')
        
        if filename.startswith('test_') and not py_file.parent.name == 'tests':
            warnings.append(f'test_ prefix file outside tests folder: {py_file}')
    
    return warnings

if __name__ == '__main__':
    result = validate_project_structure()
    print(f"Project Structure Validation: {result['status']}")
    
    if result['violations']:
        print("\nâŒ Violations:")
        for violation in result['violations']:
            print(f"  - {violation}")
    
    if result['warnings']:
        print("\nâš ï¸ Warnings:")
        for warning in result['warnings']:
            print(f"  - {warning}")
    
    if result['status'] == 'PASS':
        print("\nâœ… Project structure is valid!")
```

ì´ ê·œì¹™ë“¤ì€ ëª¨ë“  í”„ë¡œì íŠ¸ ìœ í˜•ì— ì ìš©í•  ìˆ˜ ìˆëŠ” ë²”ìš© êµ¬ì¡° ê´€ë¦¬ í‘œì¤€ì…ë‹ˆë‹¤.


