---
description: 
globs: 
alwaysApply: true
---
# ë¹„ì „ ì‹œìŠ¤í…œ ë³´ì•ˆ ê·œì¹™ (Vision System Security Rules)

ì´ ê·œì¹™ì€ ë¹„ì „ ì‹œìŠ¤í…œì˜ ë³´ì•ˆ, ë°ì´í„° ë³´í˜¸, GDPR ì¤€ìˆ˜ì— ê´€í•œ íŠ¹í™” í‘œì¤€ì…ë‹ˆë‹¤.

## ğŸ”’ ì¹´ë©”ë¼ ìŠ¤íŠ¸ë¦¼ ë³´ì•ˆ

### ë³´ì•ˆ ê°•í™” ì¹´ë©”ë¼ ê´€ë¦¬
```python
import ssl
import hashlib
import jwt
import cryptography
from cryptography.fernet import Fernet
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
import base64
import os

class SecureCameraManager:
    """ë³´ì•ˆ ê°•í™” ì¹´ë©”ë¼ ê´€ë¦¬ì"""
    
    def __init__(self, encryption_key: bytes = None):
        self.encryption_key = encryption_key or self._generate_encryption_key()
        self.cipher_suite = Fernet(self.encryption_key)
        self.ssl_context = self._create_ssl_context()
        
    def _generate_encryption_key(self) -> bytes:
        """ì•”í˜¸í™” í‚¤ ìƒì„±"""
        password = os.environ.get('CAMERA_ENCRYPTION_PASSWORD', 'default_password').encode()
        salt = os.environ.get('CAMERA_ENCRYPTION_SALT', 'default_salt').encode()
        
        kdf = PBKDF2HMAC(
            algorithm=hashes.SHA256(),
            length=32,
            salt=salt,
            iterations=100000,
        )
        key = base64.urlsafe_b64encode(kdf.derive(password))
        return key
    
    def _create_ssl_context(self) -> ssl.SSLContext:
        """SSL ì»¨í…ìŠ¤íŠ¸ ìƒì„± (RTSP over TLS)"""
        context = ssl.create_default_context(ssl.Purpose.SERVER_AUTH)
        context.check_hostname = False
        context.verify_mode = ssl.CERT_NONE  # ê°œë°œ í™˜ê²½ìš©
        return context
    
    def connect_secure_rtsp(self, rtsp_url: str, username: str, password: str) -> bool:
        """ë³´ì•ˆ RTSP ì—°ê²°"""
        try:
            # RTSP over TLS ì—°ê²°
            secure_url = rtsp_url.replace('rtsp://', 'rtsps://')
            
            # ì¸ì¦ ì •ë³´ ì•”í˜¸í™”
            encrypted_credentials = self._encrypt_credentials(username, password)
            
            # ë³´ì•ˆ ì—°ê²° ì„¤ì •
            connection = self._establish_secure_connection(secure_url, encrypted_credentials)
            
            return connection is not None
            
        except Exception as e:
            logger.error(f"ë³´ì•ˆ RTSP ì—°ê²° ì‹¤íŒ¨: {str(e)}")
            return False
    
    def _encrypt_credentials(self, username: str, password: str) -> Dict[str, str]:
        """ì¸ì¦ ì •ë³´ ì•”í˜¸í™”"""
        encrypted_username = self.cipher_suite.encrypt(username.encode())
        encrypted_password = self.cipher_suite.encrypt(password.encode())
        
        return {
            'username': base64.b64encode(encrypted_username).decode(),
            'password': base64.b64encode(encrypted_password).decode()
        }
    
    def encrypt_frame(self, frame: np.ndarray) -> bytes:
        """í”„ë ˆì„ ë°ì´í„° ì•”í˜¸í™”"""
        frame_bytes = cv2.imencode('.jpg', frame)[1].tobytes()
        encrypted_frame = self.cipher_suite.encrypt(frame_bytes)
        return encrypted_frame
    
    def decrypt_frame(self, encrypted_frame: bytes) -> np.ndarray:
        """í”„ë ˆì„ ë°ì´í„° ë³µí˜¸í™”"""
        decrypted_bytes = self.cipher_suite.decrypt(encrypted_frame)
        frame_array = np.frombuffer(decrypted_bytes, dtype=np.uint8)
        frame = cv2.imdecode(frame_array, cv2.IMREAD_COLOR)
        return frame
```

## ğŸ‘¤ ì–¼êµ´ ì¸ì‹ ë°ì´í„° ë³´í˜¸ (GDPR ì¤€ìˆ˜)

### ë°ì´í„° ìµëª…í™” ë° ë³´ì¡´ ì •ì±…
```python
class FaceDataProtection:
    """ì–¼êµ´ ì¸ì‹ ë°ì´í„° ë³´í˜¸ (GDPR ì¤€ìˆ˜)"""
    
    def __init__(self):
        self.anonymization_enabled = True
        self.retention_policy = {
            'face_embeddings': 30,  # 30ì¼
            'raw_images': 7,        # 7ì¼
            'detection_logs': 90    # 90ì¼
        }
        self.consent_manager = ConsentManager()
    
    def anonymize_face_data(self, face_data: Dict) -> Dict:
        """ì–¼êµ´ ë°ì´í„° ìµëª…í™”"""
        if not self.anonymization_enabled:
            return face_data
        
        anonymized_data = face_data.copy()
        
        # ê°œì¸ ì‹ë³„ ì •ë³´ ì œê±°
        anonymized_data.pop('person_id', None)
        anonymized_data.pop('person_name', None)
        
        # ì–¼êµ´ ì„ë² ë”© í•´ì‹±
        if 'embedding' in anonymized_data:
            embedding_hash = hashlib.sha256(
                str(anonymized_data['embedding']).encode()
            ).hexdigest()
            anonymized_data['embedding_hash'] = embedding_hash
            del anonymized_data['embedding']
        
        # íƒ€ì„ìŠ¤íƒ¬í”„ ì¼ë°˜í™” (ì‹œê°„ ë‹¨ìœ„ë¡œ)
        if 'timestamp' in anonymized_data:
            timestamp = anonymized_data['timestamp']
            anonymized_data['timestamp'] = int(timestamp // 3600) * 3600
        
        return anonymized_data
    
    def apply_retention_policy(self):
        """ë°ì´í„° ë³´ì¡´ ì •ì±… ì ìš©"""
        current_time = time.time()
        
        for data_type, retention_days in self.retention_policy.items():
            cutoff_time = current_time - (retention_days * 24 * 3600)
            self._delete_old_data(data_type, cutoff_time)
    
    def _delete_old_data(self, data_type: str, cutoff_time: float):
        """ì˜¤ë˜ëœ ë°ì´í„° ìë™ ì‚­ì œ"""
        data_dir = f"data/{data_type}"
        if not os.path.exists(data_dir):
            return
        
        deleted_count = 0
        for filename in os.listdir(data_dir):
            file_path = os.path.join(data_dir, filename)
            if os.path.getctime(file_path) < cutoff_time:
                os.remove(file_path)
                deleted_count += 1
        
        logger.info(f"{data_type}: {deleted_count}ê°œ íŒŒì¼ ì‚­ì œë¨ (ë³´ì¡´ ì •ì±…)")

class ConsentManager:
    """ì‚¬ìš©ì ë™ì˜ ê´€ë¦¬"""
    
    def __init__(self):
        self.consent_db = {}  # ì‹¤ì œë¡œëŠ” ë°ì´í„°ë² ì´ìŠ¤ ì‚¬ìš©
        
    def check_consent(self, person_id: str, purpose: str) -> bool:
        """ì‚¬ìš©ì ë™ì˜ í™•ì¸"""
        consent_key = f"{person_id}_{purpose}"
        return self.consent_db.get(consent_key, False)
    
    def record_consent(self, person_id: str, purpose: str, granted: bool):
        """ì‚¬ìš©ì ë™ì˜ ê¸°ë¡"""
        consent_key = f"{person_id}_{purpose}"
        self.consent_db[consent_key] = {
            'granted': granted,
            'timestamp': time.time(),
            'purpose': purpose
        }
```

## ğŸ” ëª¨ë¸ ë³´ì•ˆ ê´€ë¦¬

### ëª¨ë¸ ê°€ì¤‘ì¹˜ ì•”í˜¸í™” ë° ë””ì§€í„¸ ì„œëª…
```python
class ModelSecurityManager:
    """ëª¨ë¸ ë³´ì•ˆ ê´€ë¦¬"""
    
    def __init__(self):
        self.model_signatures = {}
        
    def sign_model(self, model_path: str, private_key_path: str) -> str:
        """ëª¨ë¸ íŒŒì¼ ë””ì§€í„¸ ì„œëª…"""
        from cryptography.hazmat.primitives import serialization
        from cryptography.hazmat.primitives.asymmetric import rsa, padding
        
        # ëª¨ë¸ íŒŒì¼ í•´ì‹œ ê³„ì‚°
        model_hash = self._calculate_file_hash(model_path)
        
        # ê°œì¸í‚¤ ë¡œë“œ
        with open(private_key_path, 'rb') as f:
            private_key = serialization.load_pem_private_key(
                f.read(), password=None
            )
        
        # ë””ì§€í„¸ ì„œëª… ìƒì„±
        signature = private_key.sign(
            model_hash.encode(),
            padding.PSS(
                mgf=padding.MGF1(hashes.SHA256()),
                salt_length=padding.PSS.MAX_LENGTH
            ),
            hashes.SHA256()
        )
        
        signature_b64 = base64.b64encode(signature).decode()
        self.model_signatures[model_path] = signature_b64
        
        return signature_b64
    
    def verify_model(self, model_path: str, public_key_path: str, signature: str) -> bool:
        """ëª¨ë¸ íŒŒì¼ ì„œëª… ê²€ì¦"""
        from cryptography.hazmat.primitives import serialization
        from cryptography.hazmat.primitives.asymmetric import padding
        
        try:
            # ëª¨ë¸ íŒŒì¼ í•´ì‹œ ê³„ì‚°
            model_hash = self._calculate_file_hash(model_path)
            
            # ê³µê°œí‚¤ ë¡œë“œ
            with open(public_key_path, 'rb') as f:
                public_key = serialization.load_pem_public_key(f.read())
            
            # ì„œëª… ê²€ì¦
            signature_bytes = base64.b64decode(signature)
            public_key.verify(
                signature_bytes,
                model_hash.encode(),
                padding.PSS(
                    mgf=padding.MGF1(hashes.SHA256()),
                    salt_length=padding.PSS.MAX_LENGTH
                ),
                hashes.SHA256()
            )
            
            return True
            
        except Exception as e:
            logger.error(f"ëª¨ë¸ ì„œëª… ê²€ì¦ ì‹¤íŒ¨: {str(e)}")
            return False
    
    def _calculate_file_hash(self, file_path: str) -> str:
        """íŒŒì¼ SHA256 í•´ì‹œ ê³„ì‚°"""
        sha256_hash = hashlib.sha256()
        with open(file_path, "rb") as f:
            for chunk in iter(lambda: f.read(4096), b""):
                sha256_hash.update(chunk)
        return sha256_hash.hexdigest()
    
    def encrypt_model(self, model_path: str, password: str) -> str:
        """ëª¨ë¸ íŒŒì¼ ì•”í˜¸í™”"""
        # ì•”í˜¸í™” í‚¤ ìƒì„±
        salt = os.urandom(16)
        kdf = PBKDF2HMAC(
            algorithm=hashes.SHA256(),
            length=32,
            salt=salt,
            iterations=100000,
        )
        key = base64.urlsafe_b64encode(kdf.derive(password.encode()))
        cipher_suite = Fernet(key)
        
        # ëª¨ë¸ íŒŒì¼ ì½ê¸° ë° ì•”í˜¸í™”
        with open(model_path, 'rb') as f:
            model_data = f.read()
        
        encrypted_data = cipher_suite.encrypt(model_data)
        
        # ì•”í˜¸í™”ëœ íŒŒì¼ ì €ì¥
        encrypted_path = f"{model_path}.encrypted"
        with open(encrypted_path, 'wb') as f:
            f.write(salt + encrypted_data)  # saltë¥¼ ì•ì— ë¶™ì—¬ì„œ ì €ì¥
        
        return encrypted_path
    
    def decrypt_model(self, encrypted_path: str, password: str) -> str:
        """ëª¨ë¸ íŒŒì¼ ë³µí˜¸í™”"""
        with open(encrypted_path, 'rb') as f:
            data = f.read()
        
        # salt ì¶”ì¶œ
        salt = data[:16]
        encrypted_data = data[16:]
        
        # í‚¤ ì¬ìƒì„±
        kdf = PBKDF2HMAC(
            algorithm=hashes.SHA256(),
            length=32,
            salt=salt,
            iterations=100000,
        )
        key = base64.urlsafe_b64encode(kdf.derive(password.encode()))
        cipher_suite = Fernet(key)
        
        # ë³µí˜¸í™”
        decrypted_data = cipher_suite.decrypt(encrypted_data)
        
        # ë³µí˜¸í™”ëœ íŒŒì¼ ì €ì¥
        decrypted_path = encrypted_path.replace('.encrypted', '')
        with open(decrypted_path, 'wb') as f:
            f.write(decrypted_data)
        
        return decrypted_path
```

## ğŸ›¡ï¸ API ë³´ì•ˆ ê´€ë¦¬

### JWT ì¸ì¦ ë° API ìš”ì²­ ì œí•œ
```python
class APISecurityManager:
    """API ë³´ì•ˆ ê´€ë¦¬"""
    
    def __init__(self, secret_key: str):
        self.secret_key = secret_key
        self.rate_limits = {
            'default': {'requests': 100, 'window': 3600},  # ì‹œê°„ë‹¹ 100íšŒ
            'admin': {'requests': 1000, 'window': 3600}    # ì‹œê°„ë‹¹ 1000íšŒ
        }
        self.request_counts = {}
        self.blacklisted_ips = set()
    
    def generate_jwt_token(self, user_id: str, role: str = 'user') -> str:
        """JWT í† í° ìƒì„±"""
        payload = {
            'user_id': user_id,
            'role': role,
            'exp': time.time() + 3600,  # 1ì‹œê°„ í›„ ë§Œë£Œ
            'iat': time.time()
        }
        
        token = jwt.encode(payload, self.secret_key, algorithm='HS256')
        return token
    
    def verify_jwt_token(self, token: str) -> Dict:
        """JWT í† í° ê²€ì¦"""
        try:
            payload = jwt.decode(token, self.secret_key, algorithms=['HS256'])
            return payload
        except jwt.ExpiredSignatureError:
            raise ValueError("í† í°ì´ ë§Œë£Œë¨")
        except jwt.InvalidTokenError:
            raise ValueError("ìœ íš¨í•˜ì§€ ì•Šì€ í† í°")
    
    def check_rate_limit(self, user_id: str, endpoint: str) -> bool:
        """API ìš”ì²­ ì œí•œ í™•ì¸"""
        current_time = time.time()
        key = f"{user_id}_{endpoint}"
        
        if key not in self.request_counts:
            self.request_counts[key] = []
        
        # ìœˆë„ìš° ë°–ì˜ ìš”ì²­ ì œê±°
        window_size = self.rate_limits['default']['window']
        self.request_counts[key] = [
            req_time for req_time in self.request_counts[key]
            if current_time - req_time < window_size
        ]
        
        # í˜„ì¬ ìš”ì²­ ì¶”ê°€
        self.request_counts[key].append(current_time)
        
        # ì œí•œ í™•ì¸
        max_requests = self.rate_limits['default']['requests']
        return len(self.request_counts[key]) <= max_requests
    
    def add_to_blacklist(self, ip_address: str):
        """IP ì£¼ì†Œë¥¼ ë¸”ë™ë¦¬ìŠ¤íŠ¸ì— ì¶”ê°€"""
        self.blacklisted_ips.add(ip_address)
        logger.warning(f"IP {ip_address}ê°€ ë¸”ë™ë¦¬ìŠ¤íŠ¸ì— ì¶”ê°€ë¨")
    
    def is_blacklisted(self, ip_address: str) -> bool:
        """IP ì£¼ì†Œê°€ ë¸”ë™ë¦¬ìŠ¤íŠ¸ì— ìˆëŠ”ì§€ í™•ì¸"""
        return ip_address in self.blacklisted_ips
```

## ğŸ­ ë¯¼ê°ì •ë³´ ë§ˆìŠ¤í‚¹ ë° ìµëª…í™”

### ë°ì´í„° ë§ˆìŠ¤í‚¹ í•„í„°
```python
class DataMaskingFilter:
    """ë¯¼ê°ì •ë³´ ë§ˆìŠ¤í‚¹ í•„í„°"""
    
    def __init__(self):
        self.patterns = {
            'credit_card': r'\b\d{4}[-\s]?\d{4}[-\s]?\d{4}[-\s]?\d{4}\b',
            'phone': r'\b\d{3}[-.]?\d{3}[-.]?\d{4}\b',
            'email': r'\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b',
            'ssn': r'\b\d{3}-\d{2}-\d{4}\b',
            'ip_address': r'\b\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}\b'
        }
    
    def mask_sensitive_data(self, text: str) -> str:
        """ë¯¼ê°ì •ë³´ ë§ˆìŠ¤í‚¹"""
        import re
        
        masked_text = text
        
        for data_type, pattern in self.patterns.items():
            def mask_match(match):
                matched_text = match.group(0)
                if data_type == 'email':
                    # ì´ë©”ì¼ì€ ë„ë©”ì¸ë§Œ ë³´ì¡´
                    parts = matched_text.split('@')
                    return f"***@{parts[1]}"
                elif data_type == 'credit_card':
                    # ì¹´ë“œë²ˆí˜¸ëŠ” ë§ˆì§€ë§‰ 4ìë¦¬ë§Œ ë³´ì¡´
                    return f"****-****-****-{matched_text[-4:]}"
                else:
                    # ê¸°íƒ€ëŠ” ì™„ì „ ë§ˆìŠ¤í‚¹
                    return '*' * len(matched_text)
            
            masked_text = re.sub(pattern, mask_match, masked_text)
        
        return masked_text
    
    def blur_faces(self, image: np.ndarray, blur_strength: int = 15) -> np.ndarray:
        """ì´ë¯¸ì§€ì—ì„œ ì–¼êµ´ ë¸”ëŸ¬ ì²˜ë¦¬"""
        faces = self._detect_faces_in_image(image)
        blurred_image = image.copy()
        
        for face in faces:
            x, y, w, h = face['bbox']
            # ì–¼êµ´ ì˜ì—­ ë¸”ëŸ¬ ì²˜ë¦¬
            face_region = blurred_image[y:y+h, x:x+w]
            blurred_face = cv2.GaussianBlur(face_region, (blur_strength, blur_strength), 0)
            blurred_image[y:y+h, x:x+w] = blurred_face
        
        return blurred_image
    
    def _detect_faces_in_image(self, image: np.ndarray) -> List[Dict]:
        """ì´ë¯¸ì§€ì—ì„œ ì–¼êµ´ ê°ì§€ ë° ìœ„ì¹˜ ë°˜í™˜"""
        # ì‹¤ì œ ì–¼êµ´ ê°ì§€ êµ¬í˜„ í•„ìš”
        return []
```

## ğŸŒ ë„¤íŠ¸ì›Œí¬ ë³´ì•ˆ ì„¤ì •

### ë³´ì•ˆ í—¤ë” ë° CORS ì„¤ì •
```python
class NetworkSecurityConfig:
    """ë„¤íŠ¸ì›Œí¬ ë³´ì•ˆ ì„¤ì •"""
    
    SECURITY_HEADERS = {
        'X-Content-Type-Options': 'nosniff',
        'X-Frame-Options': 'DENY',
        'X-XSS-Protection': '1; mode=block',
        'Strict-Transport-Security': 'max-age=31536000; includeSubDomains',
        'Content-Security-Policy': "default-src 'self'",
        'Referrer-Policy': 'strict-origin-when-cross-origin'
    }
    
    ALLOWED_ORIGINS = [
        'https://localhost:8000',
        'https://vision-system.company.com'
    ]
    
    CORS_CONFIG = {
        'allow_origins': ALLOWED_ORIGINS,
        'allow_credentials': True,
        'allow_methods': ['GET', 'POST'],
        'allow_headers': ['Authorization', 'Content-Type']
    }
    
    FIREWALL_RULES = {
        'incoming': {
            'allow': [
                {'port': 8000, 'protocol': 'https', 'source': 'internal'},
                {'port': 554, 'protocol': 'rtsp', 'source': 'camera_network'}
            ],
            'deny': [
                {'port': 22, 'protocol': 'ssh', 'source': 'external'},
                {'port': 3389, 'protocol': 'rdp', 'source': 'external'}
            ]
        }
    }

class SecurityAuditLogger:
    """ë³´ì•ˆ ê°ì‚¬ ë¡œê¹…"""
    
    def __init__(self):
        self.audit_logger = self._setup_audit_logger()
    
    def _setup_audit_logger(self):
        """ê°ì‚¬ ë¡œê·¸ ì„¤ì •"""
        audit_logger = logging.getLogger('security_audit')
        audit_logger.setLevel(logging.INFO)
        
        # ê°ì‚¬ ë¡œê·¸ëŠ” ë³„ë„ íŒŒì¼ì— ì €ì¥
        handler = logging.FileHandler('logs/security_audit.log')
        formatter = logging.Formatter(
            '%(asctime)s - %(levelname)s - %(message)s'
        )
        handler.setFormatter(formatter)
        audit_logger.addHandler(handler)
        
        return audit_logger
    
    def log_authentication_attempt(self, user_id: str, success: bool, ip_address: str):
        """ì¸ì¦ ì‹œë„ ë¡œê¹…"""
        status = "SUCCESS" if success else "FAILED"
        self.audit_logger.info(
            f"AUTH_{status}: user={user_id}, ip={ip_address}"
        )
    
    def log_data_access(self, user_id: str, resource: str, action: str):
        """ë°ì´í„° ì ‘ê·¼ ë¡œê¹…"""
        self.audit_logger.info(
            f"DATA_ACCESS: user={user_id}, resource={resource}, action={action}"
        )
    
    def log_security_event(self, event_type: str, details: Dict):
        """ë³´ì•ˆ ì´ë²¤íŠ¸ ë¡œê¹…"""
        self.audit_logger.warning(
            f"SECURITY_EVENT: type={event_type}, details={details}"
        )
```

## âœ… ë³´ì•ˆ ì²´í¬ë¦¬ìŠ¤íŠ¸

### í•„ìˆ˜ ë³´ì•ˆ ì„¤ì • ê²€ì¦
```python
SECURITY_CHECKLIST = {
    'encryption': {
        'camera_streams': True,      # ì¹´ë©”ë¼ ìŠ¤íŠ¸ë¦¼ ì•”í˜¸í™”
        'model_files': True,         # ëª¨ë¸ íŒŒì¼ ì•”í˜¸í™”
        'api_communications': True,  # API í†µì‹  ì•”í˜¸í™”
        'data_at_rest': True        # ì €ì¥ ë°ì´í„° ì•”í˜¸í™”
    },
    'authentication': {
        'jwt_tokens': True,         # JWT í† í° ì¸ì¦
        'api_keys': True,           # API í‚¤ ì¸ì¦
        'user_sessions': True,      # ì‚¬ìš©ì ì„¸ì…˜ ê´€ë¦¬
        'service_accounts': True    # ì„œë¹„ìŠ¤ ê³„ì • ì¸ì¦
    },
    'authorization': {
        'role_based_access': True,  # ì—­í•  ê¸°ë°˜ ì ‘ê·¼ ì œì–´
        'resource_permissions': True, # ë¦¬ì†ŒìŠ¤ ê¶Œí•œ ê´€ë¦¬
        'api_rate_limiting': True,  # API ìš”ì²­ ì œí•œ
        'audit_logging': True       # ê°ì‚¬ ë¡œê¹…
    },
    'data_protection': {
        'face_data_anonymization': True, # ì–¼êµ´ ë°ì´í„° ìµëª…í™”
        'gdpr_compliance': True,         # GDPR ì¤€ìˆ˜
        'retention_policies': True,      # ë°ì´í„° ë³´ì¡´ ì •ì±…
        'consent_management': True       # ë™ì˜ ê´€ë¦¬
    },
    'network_security': {
        'https_only': True,         # HTTPS ì „ìš©
        'cors_configuration': True, # CORS ì„¤ì •
        'security_headers': True,   # ë³´ì•ˆ í—¤ë”
        'firewall_rules': True      # ë°©í™”ë²½ ê·œì¹™
    }
}

def validate_security_configuration() -> Dict[str, bool]:
    """ë³´ì•ˆ ì„¤ì • ê²€ì¦"""
    results = {}
    
    for category, checks in SECURITY_CHECKLIST.items():
        category_results = {}
        for check_name, required in checks.items():
            # ì‹¤ì œ ê²€ì¦ ë¡œì§ êµ¬í˜„ í•„ìš”
            category_results[check_name] = required  # ì„ì‹œ
        results[category] = category_results
    
    return results
```

ì´ ë³´ì•ˆ ê·œì¹™ë“¤ì„ ì ìš©í•˜ë©´ ë¹„ì „ ì‹œìŠ¤í…œì˜ ë°ì´í„° ë³´í˜¸, ì•”í˜¸í™”, ì¸ì¦/ì¸ê°€, GDPR ì¤€ìˆ˜ ë“±ì´ ì²´ê³„ì ìœ¼ë¡œ ê´€ë¦¬ë©ë‹ˆë‹¤.

