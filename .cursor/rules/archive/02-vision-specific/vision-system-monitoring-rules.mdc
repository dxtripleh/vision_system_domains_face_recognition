---
description: 
globs: 
alwaysApply: true
---
# ë¹„ì „ ì‹œìŠ¤í…œ ëª¨ë‹ˆí„°ë§ ë° ë¡œê¹… ê³ ë„í™” ê·œì¹™ (Vision System Monitoring Rules)

ì´ ê·œì¹™ì€ ë¹„ì „ ì‹œìŠ¤í…œì˜ ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§, ì„±ëŠ¥ ì¶”ì , ì´ìƒ ê°ì§€, ë¡œê¹… ì‹œìŠ¤í…œì— ê´€í•œ íŠ¹í™” í‘œì¤€ì…ë‹ˆë‹¤.

## ğŸ“Š ì‹¤ì‹œê°„ ì„±ëŠ¥ ëŒ€ì‹œë³´ë“œ

### Prometheus & Grafana í†µí•©
```python
import time
import threading
from prometheus_client import Counter, Histogram, Gauge, start_http_server
from typing import Dict, List, Optional
import psutil
import GPUtil

class VisionSystemMetrics:
    """ë¹„ì „ ì‹œìŠ¤í…œ ë©”íŠ¸ë¦­ ìˆ˜ì§‘ê¸°"""
    
    def __init__(self, port: int = 8000):
        self.port = port
        
        # ì¹´ìš´í„° ë©”íŠ¸ë¦­
        self.frame_processed_total = Counter(
            'vision_frames_processed_total',
            'Total number of frames processed',
            ['camera_id', 'model_type']
        )
        
        self.detection_total = Counter(
            'vision_detections_total',
            'Total number of detections',
            ['class_name', 'confidence_range']
        )
        
        self.error_total = Counter(
            'vision_errors_total',
            'Total number of errors',
            ['error_type', 'component']
        )
        
        # íˆìŠ¤í† ê·¸ë¨ ë©”íŠ¸ë¦­
        self.frame_processing_duration = Histogram(
            'vision_frame_processing_seconds',
            'Time spent processing frames',
            ['camera_id', 'model_type'],
            buckets=[0.01, 0.025, 0.05, 0.1, 0.25, 0.5, 1.0, 2.5, 5.0]
        )
        
        self.model_inference_duration = Histogram(
            'vision_model_inference_seconds',
            'Time spent on model inference',
            ['model_name', 'device'],
            buckets=[0.001, 0.005, 0.01, 0.025, 0.05, 0.1, 0.25, 0.5]
        )
        
        # ê²Œì´ì§€ ë©”íŠ¸ë¦­
        self.current_fps = Gauge(
            'vision_current_fps',
            'Current frames per second',
            ['camera_id']
        )
        
        self.gpu_memory_usage = Gauge(
            'vision_gpu_memory_usage_bytes',
            'GPU memory usage in bytes',
            ['gpu_id']
        )
        
        self.cpu_usage = Gauge(
            'vision_cpu_usage_percent',
            'CPU usage percentage'
        )
        
        self.memory_usage = Gauge(
            'vision_memory_usage_bytes',
            'Memory usage in bytes'
        )
        
        self.active_cameras = Gauge(
            'vision_active_cameras',
            'Number of active cameras'
        )
        
        # ë¹„ì¦ˆë‹ˆìŠ¤ ë©”íŠ¸ë¦­
        self.defect_detection_rate = Gauge(
            'vision_defect_detection_rate',
            'Current defect detection rate',
            ['line_id', 'defect_type']
        )
        
        self.quality_score = Gauge(
            'vision_quality_score',
            'Overall quality score',
            ['metric_type']
        )
        
        # ëª¨ë‹ˆí„°ë§ ìŠ¤ë ˆë“œ
        self.monitoring_thread = None
        self.is_monitoring = False
    
    def start_monitoring(self):
        """ëª¨ë‹ˆí„°ë§ ì‹œì‘"""
        start_http_server(self.port)
        self.is_monitoring = True
        
        self.monitoring_thread = threading.Thread(
            target=self._monitoring_loop,
            daemon=True
        )
        self.monitoring_thread.start()
        
        logger.info(f"Prometheus metrics server started on port {self.port}")
    
    def stop_monitoring(self):
        """ëª¨ë‹ˆí„°ë§ ì¤‘ì§€"""
        self.is_monitoring = False
        if self.monitoring_thread:
            self.monitoring_thread.join()
    
    def _monitoring_loop(self):
        """ëª¨ë‹ˆí„°ë§ ë£¨í”„"""
        while self.is_monitoring:
            try:
                # ì‹œìŠ¤í…œ ë¦¬ì†ŒìŠ¤ ë©”íŠ¸ë¦­ ìˆ˜ì§‘
                self._collect_system_metrics()
                
                # GPU ë©”íŠ¸ë¦­ ìˆ˜ì§‘
                self._collect_gpu_metrics()
                
                time.sleep(5)  # 5ì´ˆë§ˆë‹¤ ìˆ˜ì§‘
                
            except Exception as e:
                logger.error(f"Monitoring error: {str(e)}")
    
    def _collect_system_metrics(self):
        """ì‹œìŠ¤í…œ ë©”íŠ¸ë¦­ ìˆ˜ì§‘"""
        # CPU ì‚¬ìš©ë¥ 
        cpu_percent = psutil.cpu_percent()
        self.cpu_usage.set(cpu_percent)
        
        # ë©”ëª¨ë¦¬ ì‚¬ìš©ë¥ 
        memory = psutil.virtual_memory()
        self.memory_usage.set(memory.used)
    
    def _collect_gpu_metrics(self):
        """GPU ë©”íŠ¸ë¦­ ìˆ˜ì§‘"""
        try:
            gpus = GPUtil.getGPUs()
            for gpu in gpus:
                self.gpu_memory_usage.labels(gpu_id=gpu.id).set(
                    gpu.memoryUsed * 1024 * 1024  # MB to bytes
                )
        except Exception as e:
            logger.warning(f"GPU metrics collection failed: {str(e)}")
    
    # ë©”íŠ¸ë¦­ ê¸°ë¡ ë©”ì„œë“œë“¤
    def record_frame_processed(self, camera_id: str, model_type: str, duration: float):
        """í”„ë ˆì„ ì²˜ë¦¬ ê¸°ë¡"""
        self.frame_processed_total.labels(
            camera_id=camera_id, 
            model_type=model_type
        ).inc()
        
        self.frame_processing_duration.labels(
            camera_id=camera_id,
            model_type=model_type
        ).observe(duration)
    
    def record_detection(self, class_name: str, confidence: float):
        """ê²€ì¶œ ê²°ê³¼ ê¸°ë¡"""
        confidence_range = self._get_confidence_range(confidence)
        self.detection_total.labels(
            class_name=class_name,
            confidence_range=confidence_range
        ).inc()
    
    def record_error(self, error_type: str, component: str):
        """ì—ëŸ¬ ê¸°ë¡"""
        self.error_total.labels(
            error_type=error_type,
            component=component
        ).inc()
    
    def update_fps(self, camera_id: str, fps: float):
        """FPS ì—…ë°ì´íŠ¸"""
        self.current_fps.labels(camera_id=camera_id).set(fps)
    
    def update_defect_rate(self, line_id: str, defect_type: str, rate: float):
        """ë¶ˆëŸ‰ë¥  ì—…ë°ì´íŠ¸"""
        self.defect_detection_rate.labels(
            line_id=line_id,
            defect_type=defect_type
        ).set(rate)
    
    def _get_confidence_range(self, confidence: float) -> str:
        """ì‹ ë¢°ë„ ë²”ìœ„ ë¶„ë¥˜"""
        if confidence < 0.5:
            return "low"
        elif confidence < 0.8:
            return "medium"
        else:
            return "high"
```

### Grafana ëŒ€ì‹œë³´ë“œ ì„¤ì •
```yaml
# grafana_dashboard_config.yaml
dashboard:
  title: "Vision System Monitoring"
  panels:
    - title: "System Overview"
      type: "stat"
      targets:
        - expr: "vision_current_fps"
          legendFormat: "FPS - {{ camera_id }}"
        - expr: "vision_active_cameras"
          legendFormat: "Active Cameras"
        - expr: "rate(vision_frames_processed_total[5m])"
          legendFormat: "Processing Rate"
    
    - title: "Performance Metrics"
      type: "graph"
      targets:
        - expr: "histogram_quantile(0.95, vision_frame_processing_seconds_bucket)"
          legendFormat: "95th percentile processing time"
        - expr: "histogram_quantile(0.50, vision_frame_processing_seconds_bucket)"
          legendFormat: "50th percentile processing time"
    
    - title: "Resource Usage"
      type: "graph"
      targets:
        - expr: "vision_cpu_usage_percent"
          legendFormat: "CPU Usage %"
        - expr: "vision_memory_usage_bytes / 1024 / 1024 / 1024"
          legendFormat: "Memory Usage GB"
        - expr: "vision_gpu_memory_usage_bytes / 1024 / 1024 / 1024"
          legendFormat: "GPU Memory GB - {{ gpu_id }}"
    
    - title: "Detection Statistics"
      type: "table"
      targets:
        - expr: "rate(vision_detections_total[1h])"
          legendFormat: "{{ class_name }} ({{ confidence_range }})"
    
    - title: "Error Rate"
      type: "graph"
      targets:
        - expr: "rate(vision_errors_total[5m])"
          legendFormat: "{{ error_type }} - {{ component }}"
    
    - title: "Business Metrics"
      type: "stat"
      targets:
        - expr: "vision_defect_detection_rate"
          legendFormat: "Defect Rate % - {{ line_id }}"
        - expr: "vision_quality_score"
          legendFormat: "Quality Score - {{ metric_type }}"

alerts:
  - name: "High Error Rate"
    condition: "rate(vision_errors_total[5m]) > 0.1"
    severity: "warning"
    
  - name: "Low FPS"
    condition: "vision_current_fps < 15"
    severity: "critical"
    
  - name: "High GPU Memory Usage"
    condition: "vision_gpu_memory_usage_bytes / 1024 / 1024 / 1024 > 6"
    severity: "warning"
    
  - name: "High Defect Rate"
    condition: "vision_defect_detection_rate > 0.1"
    severity: "critical"
```

## ğŸš¨ ì´ìƒ ê°ì§€ ë° ìë™ ì•Œë¦¼

### ì´ìƒ ê°ì§€ ì‹œìŠ¤í…œ
```python
import numpy as np
from sklearn.ensemble import IsolationForest
from collections import deque
import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart

class AnomalyDetector:
    """ì´ìƒ ê°ì§€ ì‹œìŠ¤í…œ"""
    
    def __init__(self, window_size: int = 100):
        self.window_size = window_size
        self.metrics_history = {
            'fps': deque(maxlen=window_size),
            'processing_time': deque(maxlen=window_size),
            'gpu_memory': deque(maxlen=window_size),
            'detection_count': deque(maxlen=window_size)
        }
        
        # ì´ìƒ ê°ì§€ ëª¨ë¸
        self.models = {}
        self._initialize_models()
        
        # ì•Œë¦¼ ì„¤ì •
        self.notification_manager = NotificationManager()
        
        # ì„ê³„ê°’ ì„¤ì •
        self.thresholds = {
            'fps_min': 15.0,
            'fps_max': 60.0,
            'processing_time_max': 0.1,  # 100ms
            'gpu_memory_max': 0.9,       # 90%
            'detection_count_min': 0,
            'detection_count_max': 100
        }
    
    def _initialize_models(self):
        """ì´ìƒ ê°ì§€ ëª¨ë¸ ì´ˆê¸°í™”"""
        for metric_name in self.metrics_history.keys():
            self.models[metric_name] = IsolationForest(
                contamination=0.1,  # 10% ì´ìƒì¹˜ í—ˆìš©
                random_state=42
            )
    
    def add_metric(self, metric_name: str, value: float):
        """ë©”íŠ¸ë¦­ ì¶”ê°€ ë° ì´ìƒ ê°ì§€"""
        if metric_name not in self.metrics_history:
            return
        
        self.metrics_history[metric_name].append(value)
        
        # ì¶©ë¶„í•œ ë°ì´í„°ê°€ ìŒ“ì´ë©´ ì´ìƒ ê°ì§€ ìˆ˜í–‰
        if len(self.metrics_history[metric_name]) >= 50:
            self._detect_anomaly(metric_name, value)
    
    def _detect_anomaly(self, metric_name: str, current_value: float):
        """ì´ìƒ ê°ì§€ ìˆ˜í–‰"""
        history = list(self.metrics_history[metric_name])
        
        # ëª¨ë¸ í›ˆë ¨ (ìµœê·¼ ë°ì´í„°ë¡œ)
        if len(history) >= 50:
            X = np.array(history[:-1]).reshape(-1, 1)
            self.models[metric_name].fit(X)
            
            # í˜„ì¬ ê°’ ì´ìƒ ê°ì§€
            current_X = np.array([[current_value]])
            anomaly_score = self.models[metric_name].decision_function(current_X)[0]
            is_anomaly = self.models[metric_name].predict(current_X)[0] == -1
            
            if is_anomaly:
                self._handle_anomaly(metric_name, current_value, anomaly_score)
    
    def _handle_anomaly(self, metric_name: str, value: float, score: float):
        """ì´ìƒ ìƒí™© ì²˜ë¦¬"""
        severity = self._calculate_severity(metric_name, value, score)
        
        alert = {
            'type': 'anomaly',
            'metric': metric_name,
            'value': value,
            'score': score,
            'severity': severity,
            'timestamp': time.time()
        }
        
        logger.warning(f"Anomaly detected: {alert}")
        self.notification_manager.send_alert(alert)
    
    def _calculate_severity(self, metric_name: str, value: float, score: float) -> str:
        """ì‹¬ê°ë„ ê³„ì‚°"""
        # ì„ê³„ê°’ ê¸°ë°˜ ì‹¬ê°ë„ íŒë‹¨
        if metric_name == 'fps':
            if value < 10:
                return 'critical'
            elif value < 15:
                return 'warning'
        elif metric_name == 'processing_time':
            if value > 0.2:
                return 'critical'
            elif value > 0.1:
                return 'warning'
        elif metric_name == 'gpu_memory':
            if value > 0.95:
                return 'critical'
            elif value > 0.85:
                return 'warning'
        
        # ì´ìƒ ì ìˆ˜ ê¸°ë°˜ ì‹¬ê°ë„
        if score < -0.5:
            return 'critical'
        elif score < -0.3:
            return 'warning'
        
        return 'info'

class NotificationManager:
    """ì•Œë¦¼ ê´€ë¦¬ì"""
    
    def __init__(self):
        self.channels = {
            'email': EmailNotifier(),
            'slack': SlackNotifier(),
            'webhook': WebhookNotifier()
        }
        
        self.alert_cooldown = {}  # ì•Œë¦¼ ì¿¨ë‹¤ìš´
        self.cooldown_period = 300  # 5ë¶„
    
    def send_alert(self, alert: Dict):
        """ì•Œë¦¼ ì „ì†¡"""
        alert_key = f"{alert['type']}_{alert['metric']}"
        current_time = time.time()
        
        # ì¿¨ë‹¤ìš´ ì²´í¬
        if alert_key in self.alert_cooldown:
            if current_time - self.alert_cooldown[alert_key] < self.cooldown_period:
                return  # ì¿¨ë‹¤ìš´ ì¤‘ì´ë¯€ë¡œ ì•Œë¦¼ ìƒëµ
        
        self.alert_cooldown[alert_key] = current_time
        
        # ì‹¬ê°ë„ì— ë”°ë¥¸ ì±„ë„ ì„ íƒ
        channels = self._select_channels(alert['severity'])
        
        for channel_name in channels:
            try:
                self.channels[channel_name].send(alert)
            except Exception as e:
                logger.error(f"Failed to send alert via {channel_name}: {str(e)}")
    
    def _select_channels(self, severity: str) -> List[str]:
        """ì‹¬ê°ë„ì— ë”°ë¥¸ ì•Œë¦¼ ì±„ë„ ì„ íƒ"""
        if severity == 'critical':
            return ['email', 'slack', 'webhook']
        elif severity == 'warning':
            return ['slack', 'webhook']
        else:
            return ['webhook']

class EmailNotifier:
    """ì´ë©”ì¼ ì•Œë¦¼"""
    
    def __init__(self):
        self.smtp_server = os.environ.get('SMTP_SERVER', 'smtp.gmail.com')
        self.smtp_port = int(os.environ.get('SMTP_PORT', '587'))
        self.username = os.environ.get('SMTP_USERNAME')
        self.password = os.environ.get('SMTP_PASSWORD')
        self.recipients = os.environ.get('ALERT_RECIPIENTS', '').split(',')
    
    def send(self, alert: Dict):
        """ì´ë©”ì¼ ì „ì†¡"""
        if not all([self.username, self.password, self.recipients]):
            logger.warning("Email configuration incomplete")
            return
        
        subject = f"Vision System Alert - {alert['severity'].upper()}"
        body = self._format_alert_message(alert)
        
        msg = MIMEMultipart()
        msg['From'] = self.username
        msg['To'] = ', '.join(self.recipients)
        msg['Subject'] = subject
        msg.attach(MIMEText(body, 'plain'))
        
        try:
            server = smtplib.SMTP(self.smtp_server, self.smtp_port)
            server.starttls()
            server.login(self.username, self.password)
            server.send_message(msg)
            server.quit()
            
            logger.info(f"Email alert sent: {subject}")
            
        except Exception as e:
            logger.error(f"Failed to send email: {str(e)}")
    
    def _format_alert_message(self, alert: Dict) -> str:
        """ì•Œë¦¼ ë©”ì‹œì§€ í¬ë§·"""
        return f"""
Vision System Alert

Type: {alert['type']}
Metric: {alert['metric']}
Value: {alert['value']}
Severity: {alert['severity']}
Time: {time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(alert['timestamp']))}

Please check the system immediately.
        """.strip()

class SlackNotifier:
    """Slack ì•Œë¦¼"""
    
    def __init__(self):
        self.webhook_url = os.environ.get('SLACK_WEBHOOK_URL')
    
    def send(self, alert: Dict):
        """Slack ë©”ì‹œì§€ ì „ì†¡"""
        if not self.webhook_url:
            logger.warning("Slack webhook URL not configured")
            return
        
        import requests
        
        color = {
            'critical': '#FF0000',
            'warning': '#FFA500',
            'info': '#00FF00'
        }.get(alert['severity'], '#808080')
        
        payload = {
            "attachments": [{
                "color": color,
                "title": f"Vision System Alert - {alert['severity'].upper()}",
                "fields": [
                    {"title": "Metric", "value": alert['metric'], "short": True},
                    {"title": "Value", "value": str(alert['value']), "short": True},
                    {"title": "Type", "value": alert['type'], "short": True},
                    {"title": "Time", "value": time.strftime('%H:%M:%S', time.localtime(alert['timestamp'])), "short": True}
                ]
            }]
        }
        
        try:
            response = requests.post(self.webhook_url, json=payload, timeout=10)
            response.raise_for_status()
            logger.info("Slack alert sent")
            
        except Exception as e:
            logger.error(f"Failed to send Slack alert: {str(e)}")

class WebhookNotifier:
    """ì›¹í›… ì•Œë¦¼"""
    
    def __init__(self):
        self.webhook_urls = os.environ.get('WEBHOOK_URLS', '').split(',')
    
    def send(self, alert: Dict):
        """ì›¹í›… ì „ì†¡"""
        if not self.webhook_urls:
            return
        
        import requests
        
        for url in self.webhook_urls:
            if not url.strip():
                continue
                
            try:
                response = requests.post(
                    url.strip(), 
                    json=alert, 
                    timeout=10,
                    headers={'Content-Type': 'application/json'}
                )
                response.raise_for_status()
                logger.info(f"Webhook alert sent to {url}")
                
            except Exception as e:
                logger.error(f"Failed to send webhook to {url}: {str(e)}")
```

## ğŸ“ˆ ë¹„ì¦ˆë‹ˆìŠ¤ ë©”íŠ¸ë¦­ ì¶”ì 

### í’ˆì§ˆ ê´€ë¦¬ ë©”íŠ¸ë¦­
```python
class QualityMetricsTracker:
    """í’ˆì§ˆ ê´€ë¦¬ ë©”íŠ¸ë¦­ ì¶”ì ê¸°"""
    
    def __init__(self):
        self.metrics_buffer = {
            'defect_detections': deque(maxlen=1000),
            'false_positives': deque(maxlen=1000),
            'false_negatives': deque(maxlen=1000),
            'processing_times': deque(maxlen=1000)
        }
        
        self.quality_targets = {
            'defect_rate_max': 0.05,    # 5% ìµœëŒ€ ë¶ˆëŸ‰ë¥ 
            'accuracy_min': 0.95,       # 95% ìµœì†Œ ì •í™•ë„
            'precision_min': 0.90,      # 90% ìµœì†Œ ì •ë°€ë„
            'recall_min': 0.85,         # 85% ìµœì†Œ ì¬í˜„ìœ¨
            'throughput_min': 100       # ì‹œê°„ë‹¹ ìµœì†Œ 100ê°œ ì²˜ë¦¬
        }
    
    def record_detection_result(self, 
                              is_defect: bool, 
                              predicted_defect: bool, 
                              confidence: float,
                              processing_time: float):
        """ê²€ì¶œ ê²°ê³¼ ê¸°ë¡"""
        
        # ì‹¤ì œ ê²°ê³¼ ê¸°ë¡
        self.metrics_buffer['defect_detections'].append({
            'actual': is_defect,
            'predicted': predicted_defect,
            'confidence': confidence,
            'timestamp': time.time()
        })
        
        self.metrics_buffer['processing_times'].append(processing_time)
        
        # False Positive/Negative ê¸°ë¡
        if predicted_defect and not is_defect:
            self.metrics_buffer['false_positives'].append(time.time())
        elif not predicted_defect and is_defect:
            self.metrics_buffer['false_negatives'].append(time.time())
    
    def calculate_quality_metrics(self, window_hours: float = 1.0) -> Dict:
        """í’ˆì§ˆ ë©”íŠ¸ë¦­ ê³„ì‚°"""
        cutoff_time = time.time() - (window_hours * 3600)
        
        # ìœˆë„ìš° ë‚´ ë°ì´í„° í•„í„°ë§
        recent_detections = [
            d for d in self.metrics_buffer['defect_detections']
            if d['timestamp'] > cutoff_time
        ]
        
        if not recent_detections:
            return {}
        
        # ê¸°ë³¸ ë©”íŠ¸ë¦­ ê³„ì‚°
        total_count = len(recent_detections)
        true_positives = sum(1 for d in recent_detections if d['actual'] and d['predicted'])
        false_positives = sum(1 for d in recent_detections if not d['actual'] and d['predicted'])
        false_negatives = sum(1 for d in recent_detections if d['actual'] and not d['predicted'])
        true_negatives = total_count - true_positives - false_positives - false_negatives
        
        # í’ˆì§ˆ ì§€í‘œ ê³„ì‚°
        accuracy = (true_positives + true_negatives) / total_count if total_count > 0 else 0
        precision = true_positives / (true_positives + false_positives) if (true_positives + false_positives) > 0 else 0
        recall = true_positives / (true_positives + false_negatives) if (true_positives + false_negatives) > 0 else 0
        f1_score = 2 * (precision * recall) / (precision + recall) if (precision + recall) > 0 else 0
        
        # ë¶ˆëŸ‰ë¥  ê³„ì‚°
        defect_count = sum(1 for d in recent_detections if d['actual'])
        defect_rate = defect_count / total_count if total_count > 0 else 0
        
        # ì²˜ë¦¬ëŸ‰ ê³„ì‚°
        throughput = total_count / window_hours
        
        # í‰ê·  ì²˜ë¦¬ ì‹œê°„
        recent_times = [
            t for t in self.metrics_buffer['processing_times']
            if time.time() - t < (window_hours * 3600)
        ]
        avg_processing_time = np.mean(recent_times) if recent_times else 0
        
        return {
            'accuracy': accuracy,
            'precision': precision,
            'recall': recall,
            'f1_score': f1_score,
            'defect_rate': defect_rate,
            'throughput_per_hour': throughput,
            'avg_processing_time_ms': avg_processing_time * 1000,
            'total_processed': total_count,
            'defects_detected': defect_count
        }
    
    def check_quality_targets(self) -> Dict[str, bool]:
        """í’ˆì§ˆ ëª©í‘œ ë‹¬ì„± ì—¬ë¶€ í™•ì¸"""
        current_metrics = self.calculate_quality_metrics()
        
        if not current_metrics:
            return {}
        
        results = {}
        results['defect_rate_ok'] = current_metrics['defect_rate'] <= self.quality_targets['defect_rate_max']
        results['accuracy_ok'] = current_metrics['accuracy'] >= self.quality_targets['accuracy_min']
        results['precision_ok'] = current_metrics['precision'] >= self.quality_targets['precision_min']
        results['recall_ok'] = current_metrics['recall'] >= self.quality_targets['recall_min']
        results['throughput_ok'] = current_metrics['throughput_per_hour'] >= self.quality_targets['throughput_min']
        
        return results
```

## ğŸ“ ê³ ê¸‰ ë¡œê¹… ì‹œìŠ¤í…œ

### êµ¬ì¡°í™”ëœ ë¡œê¹…
```python
import structlog
import json
from pythonjsonlogger import jsonlogger

class VisionSystemLogger:
    """ë¹„ì „ ì‹œìŠ¤í…œ ì „ìš© êµ¬ì¡°í™” ë¡œê¹…"""
    
    def __init__(self):
        self.setup_structured_logging()
        
    def setup_structured_logging(self):
        """êµ¬ì¡°í™” ë¡œê¹… ì„¤ì •"""
        
        # JSON í¬ë§·í„° ì„¤ì •
        json_formatter = jsonlogger.JsonFormatter(
            fmt='%(asctime)s %(name)s %(levelname)s %(message)s',
            datefmt='%Y-%m-%d %H:%M:%S'
        )
        
        # í•¸ë“¤ëŸ¬ ì„¤ì •
        handlers = {
            'console': logging.StreamHandler(),
            'file': logging.FileHandler('logs/vision_system.json'),
            'error_file': logging.FileHandler('logs/errors.json'),
            'performance_file': logging.FileHandler('logs/performance.json'),
            'business_file': logging.FileHandler('logs/business_metrics.json')
        }
        
        # ê° í•¸ë“¤ëŸ¬ì— JSON í¬ë§·í„° ì ìš©
        for handler in handlers.values():
            handler.setFormatter(json_formatter)
        
        # ë¡œê±° ì„¤ì •
        self.loggers = {
            'system': self._create_logger('vision.system', [handlers['console'], handlers['file']]),
            'performance': self._create_logger('vision.performance', [handlers['performance_file']]),
            'business': self._create_logger('vision.business', [handlers['business_file']]),
            'error': self._create_logger('vision.error', [handlers['error_file']])
        }
    
    def _create_logger(self, name: str, handlers: List) -> logging.Logger:
        """ë¡œê±° ìƒì„±"""
        logger = logging.getLogger(name)
        logger.setLevel(logging.INFO)
        
        # ê¸°ì¡´ í•¸ë“¤ëŸ¬ ì œê±°
        for handler in logger.handlers[:]:
            logger.removeHandler(handler)
        
        # ìƒˆ í•¸ë“¤ëŸ¬ ì¶”ê°€
        for handler in handlers:
            logger.addHandler(handler)
        
        return logger
    
    def log_frame_processing(self, 
                           camera_id: str, 
                           frame_id: int, 
                           processing_time: float,
                           detections: List[Dict],
                           model_info: Dict):
        """í”„ë ˆì„ ì²˜ë¦¬ ë¡œê¹…"""
        
        log_data = {
            'event_type': 'frame_processing',
            'camera_id': camera_id,
            'frame_id': frame_id,
            'processing_time_ms': processing_time * 1000,
            'detection_count': len(detections),
            'detections': detections,
            'model_name': model_info.get('name'),
            'model_version': model_info.get('version'),
            'device': model_info.get('device')
        }
        
        self.loggers['performance'].info(
            "Frame processed",
            extra=log_data
        )
    
    def log_detection_event(self, 
                          detection_type: str,
                          confidence: float,
                          bbox: List[float],
                          metadata: Dict):
        """ê²€ì¶œ ì´ë²¤íŠ¸ ë¡œê¹…"""
        
        log_data = {
            'event_type': 'detection',
            'detection_type': detection_type,
            'confidence': confidence,
            'bbox': bbox,
            'metadata': metadata
        }
        
        self.loggers['system'].info(
            f"Detection: {detection_type}",
            extra=log_data
        )
    
    def log_business_metric(self, 
                          metric_name: str,
                          value: float,
                          unit: str,
                          context: Dict):
        """ë¹„ì¦ˆë‹ˆìŠ¤ ë©”íŠ¸ë¦­ ë¡œê¹…"""
        
        log_data = {
            'event_type': 'business_metric',
            'metric_name': metric_name,
            'value': value,
            'unit': unit,
            'context': context
        }
        
        self.loggers['business'].info(
            f"Business metric: {metric_name}",
            extra=log_data
        )
    
    def log_error(self, 
                 error_type: str,
                 error_message: str,
                 component: str,
                 stack_trace: str = None,
                 context: Dict = None):
        """ì—ëŸ¬ ë¡œê¹…"""
        
        log_data = {
            'event_type': 'error',
            'error_type': error_type,
            'error_message': error_message,
            'component': component,
            'stack_trace': stack_trace,
            'context': context or {}
        }
        
        self.loggers['error'].error(
            f"Error in {component}: {error_message}",
            extra=log_data
        )
```

ì´ ëª¨ë‹ˆí„°ë§ ë° ë¡œê¹… ì‹œìŠ¤í…œì„ í†µí•´ ë¹„ì „ ì‹œìŠ¤í…œì˜ ì„±ëŠ¥, í’ˆì§ˆ, ì˜¤ë¥˜ë¥¼ ì‹¤ì‹œê°„ìœ¼ë¡œ ì¶”ì í•˜ê³  ê´€ë¦¬í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

