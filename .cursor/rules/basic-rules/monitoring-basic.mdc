---
description: 
globs: 
alwaysApply: false
---
# ê¸°ë³¸ ëª¨ë‹ˆí„°ë§ ê·œì¹™ (Basic)

## âš ï¸ í˜„ì‹¤ì  í•œê³„ ë° ì ìš© ì•ˆë‚´
- **ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§**: ê¸°ë³¸ êµ¬í˜„ì€ ì œê³µë˜ì§€ë§Œ, ì‹¤ì œ ìš´ì˜ì—ì„œëŠ” ë³„ë„ ëª¨ë‹ˆí„°ë§ ì„œë²„ ì„¤ì • í•„ìš”
- **ì•Œë¦¼ ì‹œìŠ¤í…œ**: ë¡œê·¸ ê¸°ë°˜ ì•Œë¦¼ë§Œ ì œê³µ, ì´ë©”ì¼/Slack ë“± ì™¸ë¶€ ì•Œë¦¼ì€ ë³„ë„ êµ¬í˜„ í•„ìš”
- **ë©”íŠ¸ë¦­ ì €ì¥**: JSON íŒŒì¼ë¡œ ì €ì¥ë˜ë©°, ì‹œê³„ì—´ DB ì—°ë™ì€ ë³„ë„ êµ¬í˜„ í•„ìš”
- **ìë™ ì •ë¦¬**: ë©”íŠ¸ë¦­ íŒŒì¼ ìë™ ì •ë¦¬ëŠ” ë³„ë„ ìŠ¤ì¼€ì¤„ëŸ¬ ì„¤ì • í•„ìš”

## ğŸ“Š ê¸°ë³¸ ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§

### ì„±ëŠ¥ ì¸¡ì • í´ë˜ìŠ¤
```python
import time
import psutil
import logging
from collections import deque
from typing import Dict, List, Optional
import json
from pathlib import Path

logger = logging.getLogger(__name__)


class BasicPerformanceMonitor:
    """ê¸°ë³¸ ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§"""
    
    def __init__(self, history_size: int = 100):
        self.history_size = history_size
        self.fps_history = deque(maxlen=history_size)
        self.processing_times = deque(maxlen=history_size)
        self.memory_usage = deque(maxlen=history_size)
        self.cpu_usage = deque(maxlen=history_size)
        
        self.frame_count = 0
        self.start_time = time.time()
        self.is_monitoring = False
        
        # ë¡œê·¸ ë””ë ‰í† ë¦¬ ìƒì„±
        self.log_dir = Path("data/logs")
        self.log_dir.mkdir(parents=True, exist_ok=True)
    
    def start_monitoring(self):
        """ëª¨ë‹ˆí„°ë§ ì‹œì‘"""
        if self.is_monitoring:
            return
        
        self.is_monitoring = True
        self.frame_count = 0
        self.start_time = time.time()
        logger.info("Performance monitoring started")
    
    def stop_monitoring(self):
        """ëª¨ë‹ˆí„°ë§ ì¤‘ì§€"""
        self.is_monitoring = False
        self._save_final_report()
        logger.info("Performance monitoring stopped")
    
    def record_frame_processing(self, processing_time_ms: float):
        """í”„ë ˆì„ ì²˜ë¦¬ ì‹œê°„ ê¸°ë¡"""
        if not self.is_monitoring:
            return
        
        self.frame_count += 1
        self.processing_times.append(processing_time_ms)
        
        # FPS ê³„ì‚°
        elapsed_time = time.time() - self.start_time
        if elapsed_time > 0:
            current_fps = self.frame_count / elapsed_time
            self.fps_history.append(current_fps)
        
        # ì‹œìŠ¤í…œ ë¦¬ì†ŒìŠ¤ ê¸°ë¡
        self._record_system_metrics()
    
    def _record_system_metrics(self):
        """ì‹œìŠ¤í…œ ë©”íŠ¸ë¦­ ê¸°ë¡"""
        try:
            # CPU ì‚¬ìš©ë¥ 
            cpu_percent = psutil.cpu_percent()
            self.cpu_usage.append(cpu_percent)
            
            # ë©”ëª¨ë¦¬ ì‚¬ìš©ë¥ 
            memory = psutil.virtual_memory()
            memory_mb = memory.used / (1024 * 1024)  # MB
            self.memory_usage.append(memory_mb)
            
        except Exception as e:
            logger.warning(f"Failed to record system metrics: {e}")
    
    def get_current_stats(self) -> Dict:
        """í˜„ì¬ í†µê³„ ë°˜í™˜"""
        if not self.fps_history:
            return {}
        
        return {
            'current_fps': self.fps_history[-1] if self.fps_history else 0,
            'avg_fps': sum(self.fps_history) / len(self.fps_history),
            'avg_processing_time_ms': sum(self.processing_times) / len(self.processing_times) if self.processing_times else 0,
            'total_frames': self.frame_count,
            'current_cpu_percent': self.cpu_usage[-1] if self.cpu_usage else 0,
            'current_memory_mb': self.memory_usage[-1] if self.memory_usage else 0
        }
    
    def _save_final_report(self):
        """ìµœì¢… ë¦¬í¬íŠ¸ ì €ì¥"""
        stats = self.get_current_stats()
        
        report = {
            'timestamp': time.strftime('%Y-%m-%d %H:%M:%S'),
            'summary': stats,
            'history': {
                'fps': list(self.fps_history),
                'processing_times': list(self.processing_times),
                'cpu_usage': list(self.cpu_usage),
                'memory_usage': list(self.memory_usage)
            }
        }
        
        report_file = self.log_dir / f"performance_report_{int(time.time())}.json"
        with open(report_file, 'w', encoding='utf-8') as f:
            json.dump(report, f, indent=2, ensure_ascii=False)
        
        logger.info(f"Performance report saved: {report_file}")
```

### ì–¼êµ´ ê²€ì¶œ ëª¨ë‹ˆí„°ë§
```python
class FaceDetectionMonitor:
    """ì–¼êµ´ ê²€ì¶œ ëª¨ë‹ˆí„°ë§"""
    
    def __init__(self):
        self.detection_history = deque(maxlen=1000)
        self.error_count = 0
        self.success_count = 0
        
    def record_detection(self, 
                        face_count: int, 
                        processing_time_ms: float,
                        confidence_scores: List[float],
                        success: bool = True):
        """ê²€ì¶œ ê²°ê³¼ ê¸°ë¡"""
        detection_record = {
            'timestamp': time.time(),
            'face_count': face_count,
            'processing_time_ms': processing_time_ms,
            'avg_confidence': sum(confidence_scores) / len(confidence_scores) if confidence_scores else 0,
            'max_confidence': max(confidence_scores) if confidence_scores else 0,
            'success': success
        }
        
        self.detection_history.append(detection_record)
        
        if success:
            self.success_count += 1
        else:
            self.error_count += 1
    
    def get_detection_stats(self) -> Dict:
        """ê²€ì¶œ í†µê³„ ë°˜í™˜"""
        if not self.detection_history:
            return {}
        
        recent_detections = list(self.detection_history)[-100:]  # ìµœê·¼ 100ê°œ
        
        return {
            'total_detections': len(self.detection_history),
            'success_rate': self.success_count / (self.success_count + self.error_count) if (self.success_count + self.error_count) > 0 else 0,
            'avg_face_count': sum(d['face_count'] for d in recent_detections) / len(recent_detections),
            'avg_processing_time': sum(d['processing_time_ms'] for d in recent_detections) / len(recent_detections),
            'avg_confidence': sum(d['avg_confidence'] for d in recent_detections) / len(recent_detections)
        }
```

## ğŸš¨ ê¸°ë³¸ ì•Œë¦¼ ì‹œìŠ¤í…œ

### ê°„ë‹¨í•œ ì•Œë¦¼ ê´€ë¦¬ì
```python
class BasicAlertManager:
    """ê¸°ë³¸ ì•Œë¦¼ ê´€ë¦¬ì"""
    
    def __init__(self):
        self.alert_thresholds = {
            'fps_min': 15.0,
            'processing_time_max_ms': 100.0,
            'memory_max_mb': 1000.0,
            'error_rate_max': 0.1
        }
        self.alert_history = []
    
    def check_performance_alerts(self, stats: Dict) -> List[str]:
        """ì„±ëŠ¥ ì•Œë¦¼ í™•ì¸"""
        alerts = []
        
        # FPS ì²´í¬
        if stats.get('current_fps', 0) < self.alert_thresholds['fps_min']:
            alerts.append(f"Low FPS: {stats.get('current_fps', 0):.1f}")
        
        # ì²˜ë¦¬ ì‹œê°„ ì²´í¬
        if stats.get('avg_processing_time_ms', 0) > self.alert_thresholds['processing_time_max_ms']:
            alerts.append(f"High processing time: {stats.get('avg_processing_time_ms', 0):.1f}ms")
        
        # ë©”ëª¨ë¦¬ ì²´í¬
        if stats.get('current_memory_mb', 0) > self.alert_thresholds['memory_max_mb']:
            alerts.append(f"High memory usage: {stats.get('current_memory_mb', 0):.1f}MB")
        
        return alerts
    
    def log_alerts(self, alerts: List[str]):
        """ì•Œë¦¼ ë¡œê¹…"""
        for alert in alerts:
            logger.warning(f"PERFORMANCE ALERT: {alert}")
            self.alert_history.append({
                'timestamp': time.time(),
                'message': alert
            })
```

## ğŸ“ˆ ê¸°ë³¸ ë©”íŠ¸ë¦­ ìˆ˜ì§‘

### ë©”íŠ¸ë¦­ ìˆ˜ì§‘ê¸°
```python
class BasicMetricsCollector:
    """ê¸°ë³¸ ë©”íŠ¸ë¦­ ìˆ˜ì§‘ê¸°"""
    
    def __init__(self):
        self.metrics_dir = Path("data/logs/metrics")
        self.metrics_dir.mkdir(parents=True, exist_ok=True)
        
        self.performance_monitor = BasicPerformanceMonitor()
        self.detection_monitor = FaceDetectionMonitor()
        self.alert_manager = BasicAlertManager()
    
    def start_collection(self):
        """ë©”íŠ¸ë¦­ ìˆ˜ì§‘ ì‹œì‘"""
        self.performance_monitor.start_monitoring()
        logger.info("Metrics collection started")
    
    def stop_collection(self):
        """ë©”íŠ¸ë¦­ ìˆ˜ì§‘ ì¤‘ì§€"""
        self.performance_monitor.stop_monitoring()
        self._save_metrics()
        logger.info("Metrics collection stopped")
    
    def record_vision_metrics(self, 
                            face_count: int,
                            processing_time_ms: float,
                            confidence_scores: List[float],
                            success: bool = True):
        """ë¹„ì „ ë©”íŠ¸ë¦­ ê¸°ë¡"""
        self.performance_monitor.record_frame_processing(processing_time_ms)
        self.detection_monitor.record_detection(
            face_count, processing_time_ms, confidence_scores, success
        )
        
        # ì•Œë¦¼ í™•ì¸
        stats = self.performance_monitor.get_current_stats()
        alerts = self.alert_manager.check_performance_alerts(stats)
        self.alert_manager.log_alerts(alerts)
    
    def _save_metrics(self):
        """ë©”íŠ¸ë¦­ ì €ì¥"""
        timestamp = int(time.time())
        
        # ì„±ëŠ¥ ë©”íŠ¸ë¦­
        performance_stats = self.performance_monitor.get_current_stats()
        performance_file = self.metrics_dir / f"performance_{timestamp}.json"
        with open(performance_file, 'w', encoding='utf-8') as f:
            json.dump(performance_stats, f, indent=2, ensure_ascii=False)
        
        # ê²€ì¶œ ë©”íŠ¸ë¦­
        detection_stats = self.detection_monitor.get_detection_stats()
        detection_file = self.metrics_dir / f"detection_{timestamp}.json"
        with open(detection_file, 'w', encoding='utf-8') as f:
            json.dump(detection_stats, f, indent=2, ensure_ascii=False)
        
        logger.info(f"Metrics saved: {performance_file}, {detection_file}")
```

## ğŸ”§ ì‹¤ì œ ì ìš© ì˜ˆì‹œ

### ë°ëª¨ì—ì„œ ëª¨ë‹ˆí„°ë§ ì‚¬ìš©
```python
def setup_basic_monitoring():
    """ê¸°ë³¸ ëª¨ë‹ˆí„°ë§ ì„¤ì •"""
    metrics_collector = BasicMetricsCollector()
    metrics_collector.start_collection()
    return metrics_collector

def run_demo_with_monitoring():
    """ëª¨ë‹ˆí„°ë§ê³¼ í•¨ê»˜ ë°ëª¨ ì‹¤í–‰"""
    metrics_collector = setup_basic_monitoring()
    
    try:
        # ë©”ì¸ ì²˜ë¦¬ ë£¨í”„
        while True:
            start_time = time.time()
            
            # ì–¼êµ´ ê²€ì¶œ
            detection_result = detection_service.detect_faces(frame)
            processing_time = (time.time() - start_time) * 1000
            
            # ë©”íŠ¸ë¦­ ê¸°ë¡
            confidence_scores = [face.confidence.value for face in detection_result.faces]
            metrics_collector.record_vision_metrics(
                face_count=len(detection_result.faces),
                processing_time_ms=processing_time,
                confidence_scores=confidence_scores,
                success=True
            )
            
    finally:
        metrics_collector.stop_collection()
```

### ì‹¤ì œ ë°ëª¨ ì½”ë“œì— ì ìš©
```python
# domains/face_recognition/runners/recognition/run_demo.pyì— ì¶”ê°€
from shared.monitoring import BasicMetricsCollector

class RealtimeDemo:
    def __init__(self, camera_id: int = 0):
        # ... ê¸°ì¡´ ì´ˆê¸°í™” ì½”ë“œ ...
        
        # ëª¨ë‹ˆí„°ë§ ì¶”ê°€
        self.metrics_collector = BasicMetricsCollector()
    
    def run(self):
        # ëª¨ë‹ˆí„°ë§ ì‹œì‘
        self.metrics_collector.start_collection()
        
        try:
            while True:
                # ... ê¸°ì¡´ í”„ë ˆì„ ì²˜ë¦¬ ì½”ë“œ ...
                
                # ë©”íŠ¸ë¦­ ê¸°ë¡
                confidence_scores = [face.confidence.value for face in faces]
                self.metrics_collector.record_vision_metrics(
                    face_count=len(faces),
                    processing_time_ms=processing_time,
                    confidence_scores=confidence_scores,
                    success=True
                )
                
        finally:
            # ëª¨ë‹ˆí„°ë§ ì¤‘ì§€
            self.metrics_collector.stop_collection()
```

## ğŸ“‹ ëª¨ë‹ˆí„°ë§ ì²´í¬ë¦¬ìŠ¤íŠ¸

### í•„ìˆ˜ êµ¬í˜„ í•­ëª©
- [ ] ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§ (FPS, ì²˜ë¦¬ì‹œê°„, CPU, ë©”ëª¨ë¦¬)
- [ ] ê²€ì¶œ ëª¨ë‹ˆí„°ë§ (ì–¼êµ´ ìˆ˜, ì‹ ë¢°ë„, ì„±ê³µë¥ )
- [ ] ê¸°ë³¸ ì•Œë¦¼ ì‹œìŠ¤í…œ (ì„ê³„ê°’ ê¸°ë°˜)
- [ ] ë©”íŠ¸ë¦­ ì €ì¥ (JSON íŒŒì¼)

### ê¶Œì¥ êµ¬í˜„ í•­ëª©
- [ ] ì‹¤ì‹œê°„ ëŒ€ì‹œë³´ë“œ (ê°„ë‹¨í•œ ì›¹ ì¸í„°í˜ì´ìŠ¤)
- [ ] ë©”íŠ¸ë¦­ ì‹œê°í™” (matplotlib/plotly)
- [ ] ì•Œë¦¼ ì´ë©”ì¼/Slack ì—°ë™
- [ ] ë©”íŠ¸ë¦­ ìë™ ì •ë¦¬

### ì„ íƒì  êµ¬í˜„ í•­ëª©
- [ ] Prometheus/Grafana ì—°ë™
- [ ] ì‹œê³„ì—´ ë°ì´í„°ë² ì´ìŠ¤ ì—°ë™
- [ ] ê³ ê¸‰ ì•Œë¦¼ (ì´ìƒ ê°ì§€, ì˜ˆì¸¡)

- [ ] ë¹„ì¦ˆë‹ˆìŠ¤ ë©”íŠ¸ë¦­ ì¶”ì 